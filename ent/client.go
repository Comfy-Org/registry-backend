// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"registry-backend/ent/migrate"

	"registry-backend/ent/ciworkflowresult"
	"registry-backend/ent/gitcommit"
	"registry-backend/ent/node"
	"registry-backend/ent/nodeversion"
	"registry-backend/ent/personalaccesstoken"
	"registry-backend/ent/publisher"
	"registry-backend/ent/publisherpermission"
	"registry-backend/ent/storagefile"
	"registry-backend/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CIWorkflowResult is the client for interacting with the CIWorkflowResult builders.
	CIWorkflowResult *CIWorkflowResultClient
	// GitCommit is the client for interacting with the GitCommit builders.
	GitCommit *GitCommitClient
	// Node is the client for interacting with the Node builders.
	Node *NodeClient
	// NodeVersion is the client for interacting with the NodeVersion builders.
	NodeVersion *NodeVersionClient
	// PersonalAccessToken is the client for interacting with the PersonalAccessToken builders.
	PersonalAccessToken *PersonalAccessTokenClient
	// Publisher is the client for interacting with the Publisher builders.
	Publisher *PublisherClient
	// PublisherPermission is the client for interacting with the PublisherPermission builders.
	PublisherPermission *PublisherPermissionClient
	// StorageFile is the client for interacting with the StorageFile builders.
	StorageFile *StorageFileClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CIWorkflowResult = NewCIWorkflowResultClient(c.config)
	c.GitCommit = NewGitCommitClient(c.config)
	c.Node = NewNodeClient(c.config)
	c.NodeVersion = NewNodeVersionClient(c.config)
	c.PersonalAccessToken = NewPersonalAccessTokenClient(c.config)
	c.Publisher = NewPublisherClient(c.config)
	c.PublisherPermission = NewPublisherPermissionClient(c.config)
	c.StorageFile = NewStorageFileClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		CIWorkflowResult:    NewCIWorkflowResultClient(cfg),
		GitCommit:           NewGitCommitClient(cfg),
		Node:                NewNodeClient(cfg),
		NodeVersion:         NewNodeVersionClient(cfg),
		PersonalAccessToken: NewPersonalAccessTokenClient(cfg),
		Publisher:           NewPublisherClient(cfg),
		PublisherPermission: NewPublisherPermissionClient(cfg),
		StorageFile:         NewStorageFileClient(cfg),
		User:                NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		CIWorkflowResult:    NewCIWorkflowResultClient(cfg),
		GitCommit:           NewGitCommitClient(cfg),
		Node:                NewNodeClient(cfg),
		NodeVersion:         NewNodeVersionClient(cfg),
		PersonalAccessToken: NewPersonalAccessTokenClient(cfg),
		Publisher:           NewPublisherClient(cfg),
		PublisherPermission: NewPublisherPermissionClient(cfg),
		StorageFile:         NewStorageFileClient(cfg),
		User:                NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CIWorkflowResult.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.CIWorkflowResult, c.GitCommit, c.Node, c.NodeVersion, c.PersonalAccessToken,
		c.Publisher, c.PublisherPermission, c.StorageFile, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.CIWorkflowResult, c.GitCommit, c.Node, c.NodeVersion, c.PersonalAccessToken,
		c.Publisher, c.PublisherPermission, c.StorageFile, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CIWorkflowResultMutation:
		return c.CIWorkflowResult.mutate(ctx, m)
	case *GitCommitMutation:
		return c.GitCommit.mutate(ctx, m)
	case *NodeMutation:
		return c.Node.mutate(ctx, m)
	case *NodeVersionMutation:
		return c.NodeVersion.mutate(ctx, m)
	case *PersonalAccessTokenMutation:
		return c.PersonalAccessToken.mutate(ctx, m)
	case *PublisherMutation:
		return c.Publisher.mutate(ctx, m)
	case *PublisherPermissionMutation:
		return c.PublisherPermission.mutate(ctx, m)
	case *StorageFileMutation:
		return c.StorageFile.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CIWorkflowResultClient is a client for the CIWorkflowResult schema.
type CIWorkflowResultClient struct {
	config
}

// NewCIWorkflowResultClient returns a client for the CIWorkflowResult from the given config.
func NewCIWorkflowResultClient(c config) *CIWorkflowResultClient {
	return &CIWorkflowResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ciworkflowresult.Hooks(f(g(h())))`.
func (c *CIWorkflowResultClient) Use(hooks ...Hook) {
	c.hooks.CIWorkflowResult = append(c.hooks.CIWorkflowResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ciworkflowresult.Intercept(f(g(h())))`.
func (c *CIWorkflowResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.CIWorkflowResult = append(c.inters.CIWorkflowResult, interceptors...)
}

// Create returns a builder for creating a CIWorkflowResult entity.
func (c *CIWorkflowResultClient) Create() *CIWorkflowResultCreate {
	mutation := newCIWorkflowResultMutation(c.config, OpCreate)
	return &CIWorkflowResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CIWorkflowResult entities.
func (c *CIWorkflowResultClient) CreateBulk(builders ...*CIWorkflowResultCreate) *CIWorkflowResultCreateBulk {
	return &CIWorkflowResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CIWorkflowResultClient) MapCreateBulk(slice any, setFunc func(*CIWorkflowResultCreate, int)) *CIWorkflowResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CIWorkflowResultCreateBulk{err: fmt.Errorf("calling to CIWorkflowResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CIWorkflowResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CIWorkflowResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CIWorkflowResult.
func (c *CIWorkflowResultClient) Update() *CIWorkflowResultUpdate {
	mutation := newCIWorkflowResultMutation(c.config, OpUpdate)
	return &CIWorkflowResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CIWorkflowResultClient) UpdateOne(cwr *CIWorkflowResult) *CIWorkflowResultUpdateOne {
	mutation := newCIWorkflowResultMutation(c.config, OpUpdateOne, withCIWorkflowResult(cwr))
	return &CIWorkflowResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CIWorkflowResultClient) UpdateOneID(id uuid.UUID) *CIWorkflowResultUpdateOne {
	mutation := newCIWorkflowResultMutation(c.config, OpUpdateOne, withCIWorkflowResultID(id))
	return &CIWorkflowResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CIWorkflowResult.
func (c *CIWorkflowResultClient) Delete() *CIWorkflowResultDelete {
	mutation := newCIWorkflowResultMutation(c.config, OpDelete)
	return &CIWorkflowResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CIWorkflowResultClient) DeleteOne(cwr *CIWorkflowResult) *CIWorkflowResultDeleteOne {
	return c.DeleteOneID(cwr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CIWorkflowResultClient) DeleteOneID(id uuid.UUID) *CIWorkflowResultDeleteOne {
	builder := c.Delete().Where(ciworkflowresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CIWorkflowResultDeleteOne{builder}
}

// Query returns a query builder for CIWorkflowResult.
func (c *CIWorkflowResultClient) Query() *CIWorkflowResultQuery {
	return &CIWorkflowResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCIWorkflowResult},
		inters: c.Interceptors(),
	}
}

// Get returns a CIWorkflowResult entity by its id.
func (c *CIWorkflowResultClient) Get(ctx context.Context, id uuid.UUID) (*CIWorkflowResult, error) {
	return c.Query().Where(ciworkflowresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CIWorkflowResultClient) GetX(ctx context.Context, id uuid.UUID) *CIWorkflowResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGitcommit queries the gitcommit edge of a CIWorkflowResult.
func (c *CIWorkflowResultClient) QueryGitcommit(cwr *CIWorkflowResult) *GitCommitQuery {
	query := (&GitCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cwr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ciworkflowresult.Table, ciworkflowresult.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ciworkflowresult.GitcommitTable, ciworkflowresult.GitcommitColumn),
		)
		fromV = sqlgraph.Neighbors(cwr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStorageFile queries the storage_file edge of a CIWorkflowResult.
func (c *CIWorkflowResultClient) QueryStorageFile(cwr *CIWorkflowResult) *StorageFileQuery {
	query := (&StorageFileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cwr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ciworkflowresult.Table, ciworkflowresult.FieldID, id),
			sqlgraph.To(storagefile.Table, storagefile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, ciworkflowresult.StorageFileTable, ciworkflowresult.StorageFileColumn),
		)
		fromV = sqlgraph.Neighbors(cwr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CIWorkflowResultClient) Hooks() []Hook {
	return c.hooks.CIWorkflowResult
}

// Interceptors returns the client interceptors.
func (c *CIWorkflowResultClient) Interceptors() []Interceptor {
	return c.inters.CIWorkflowResult
}

func (c *CIWorkflowResultClient) mutate(ctx context.Context, m *CIWorkflowResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CIWorkflowResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CIWorkflowResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CIWorkflowResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CIWorkflowResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CIWorkflowResult mutation op: %q", m.Op())
	}
}

// GitCommitClient is a client for the GitCommit schema.
type GitCommitClient struct {
	config
}

// NewGitCommitClient returns a client for the GitCommit from the given config.
func NewGitCommitClient(c config) *GitCommitClient {
	return &GitCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gitcommit.Hooks(f(g(h())))`.
func (c *GitCommitClient) Use(hooks ...Hook) {
	c.hooks.GitCommit = append(c.hooks.GitCommit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gitcommit.Intercept(f(g(h())))`.
func (c *GitCommitClient) Intercept(interceptors ...Interceptor) {
	c.inters.GitCommit = append(c.inters.GitCommit, interceptors...)
}

// Create returns a builder for creating a GitCommit entity.
func (c *GitCommitClient) Create() *GitCommitCreate {
	mutation := newGitCommitMutation(c.config, OpCreate)
	return &GitCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GitCommit entities.
func (c *GitCommitClient) CreateBulk(builders ...*GitCommitCreate) *GitCommitCreateBulk {
	return &GitCommitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GitCommitClient) MapCreateBulk(slice any, setFunc func(*GitCommitCreate, int)) *GitCommitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GitCommitCreateBulk{err: fmt.Errorf("calling to GitCommitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GitCommitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GitCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GitCommit.
func (c *GitCommitClient) Update() *GitCommitUpdate {
	mutation := newGitCommitMutation(c.config, OpUpdate)
	return &GitCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GitCommitClient) UpdateOne(gc *GitCommit) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommit(gc))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GitCommitClient) UpdateOneID(id uuid.UUID) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommitID(id))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GitCommit.
func (c *GitCommitClient) Delete() *GitCommitDelete {
	mutation := newGitCommitMutation(c.config, OpDelete)
	return &GitCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GitCommitClient) DeleteOne(gc *GitCommit) *GitCommitDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GitCommitClient) DeleteOneID(id uuid.UUID) *GitCommitDeleteOne {
	builder := c.Delete().Where(gitcommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GitCommitDeleteOne{builder}
}

// Query returns a query builder for GitCommit.
func (c *GitCommitClient) Query() *GitCommitQuery {
	return &GitCommitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGitCommit},
		inters: c.Interceptors(),
	}
}

// Get returns a GitCommit entity by its id.
func (c *GitCommitClient) Get(ctx context.Context, id uuid.UUID) (*GitCommit, error) {
	return c.Query().Where(gitcommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GitCommitClient) GetX(ctx context.Context, id uuid.UUID) *GitCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResults queries the results edge of a GitCommit.
func (c *GitCommitClient) QueryResults(gc *GitCommit) *CIWorkflowResultQuery {
	query := (&CIWorkflowResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(ciworkflowresult.Table, ciworkflowresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, gitcommit.ResultsTable, gitcommit.ResultsColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GitCommitClient) Hooks() []Hook {
	return c.hooks.GitCommit
}

// Interceptors returns the client interceptors.
func (c *GitCommitClient) Interceptors() []Interceptor {
	return c.inters.GitCommit
}

func (c *GitCommitClient) mutate(ctx context.Context, m *GitCommitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GitCommitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GitCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GitCommitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GitCommit mutation op: %q", m.Op())
	}
}

// NodeClient is a client for the Node schema.
type NodeClient struct {
	config
}

// NewNodeClient returns a client for the Node from the given config.
func NewNodeClient(c config) *NodeClient {
	return &NodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `node.Hooks(f(g(h())))`.
func (c *NodeClient) Use(hooks ...Hook) {
	c.hooks.Node = append(c.hooks.Node, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `node.Intercept(f(g(h())))`.
func (c *NodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Node = append(c.inters.Node, interceptors...)
}

// Create returns a builder for creating a Node entity.
func (c *NodeClient) Create() *NodeCreate {
	mutation := newNodeMutation(c.config, OpCreate)
	return &NodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Node entities.
func (c *NodeClient) CreateBulk(builders ...*NodeCreate) *NodeCreateBulk {
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeClient) MapCreateBulk(slice any, setFunc func(*NodeCreate, int)) *NodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeCreateBulk{err: fmt.Errorf("calling to NodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Node.
func (c *NodeClient) Update() *NodeUpdate {
	mutation := newNodeMutation(c.config, OpUpdate)
	return &NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeClient) UpdateOne(n *Node) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNode(n))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeClient) UpdateOneID(id string) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNodeID(id))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Node.
func (c *NodeClient) Delete() *NodeDelete {
	mutation := newNodeMutation(c.config, OpDelete)
	return &NodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeClient) DeleteOne(n *Node) *NodeDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeClient) DeleteOneID(id string) *NodeDeleteOne {
	builder := c.Delete().Where(node.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeDeleteOne{builder}
}

// Query returns a query builder for Node.
func (c *NodeClient) Query() *NodeQuery {
	return &NodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNode},
		inters: c.Interceptors(),
	}
}

// Get returns a Node entity by its id.
func (c *NodeClient) Get(ctx context.Context, id string) (*Node, error) {
	return c.Query().Where(node.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeClient) GetX(ctx context.Context, id string) *Node {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPublisher queries the publisher edge of a Node.
func (c *NodeClient) QueryPublisher(n *Node) *PublisherQuery {
	query := (&PublisherClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(publisher.Table, publisher.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, node.PublisherTable, node.PublisherColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a Node.
func (c *NodeClient) QueryVersions(n *Node) *NodeVersionQuery {
	query := (&NodeVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(nodeversion.Table, nodeversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.VersionsTable, node.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeClient) Hooks() []Hook {
	return c.hooks.Node
}

// Interceptors returns the client interceptors.
func (c *NodeClient) Interceptors() []Interceptor {
	return c.inters.Node
}

func (c *NodeClient) mutate(ctx context.Context, m *NodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Node mutation op: %q", m.Op())
	}
}

// NodeVersionClient is a client for the NodeVersion schema.
type NodeVersionClient struct {
	config
}

// NewNodeVersionClient returns a client for the NodeVersion from the given config.
func NewNodeVersionClient(c config) *NodeVersionClient {
	return &NodeVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nodeversion.Hooks(f(g(h())))`.
func (c *NodeVersionClient) Use(hooks ...Hook) {
	c.hooks.NodeVersion = append(c.hooks.NodeVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nodeversion.Intercept(f(g(h())))`.
func (c *NodeVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.NodeVersion = append(c.inters.NodeVersion, interceptors...)
}

// Create returns a builder for creating a NodeVersion entity.
func (c *NodeVersionClient) Create() *NodeVersionCreate {
	mutation := newNodeVersionMutation(c.config, OpCreate)
	return &NodeVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NodeVersion entities.
func (c *NodeVersionClient) CreateBulk(builders ...*NodeVersionCreate) *NodeVersionCreateBulk {
	return &NodeVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeVersionClient) MapCreateBulk(slice any, setFunc func(*NodeVersionCreate, int)) *NodeVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeVersionCreateBulk{err: fmt.Errorf("calling to NodeVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NodeVersion.
func (c *NodeVersionClient) Update() *NodeVersionUpdate {
	mutation := newNodeVersionMutation(c.config, OpUpdate)
	return &NodeVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeVersionClient) UpdateOne(nv *NodeVersion) *NodeVersionUpdateOne {
	mutation := newNodeVersionMutation(c.config, OpUpdateOne, withNodeVersion(nv))
	return &NodeVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeVersionClient) UpdateOneID(id uuid.UUID) *NodeVersionUpdateOne {
	mutation := newNodeVersionMutation(c.config, OpUpdateOne, withNodeVersionID(id))
	return &NodeVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NodeVersion.
func (c *NodeVersionClient) Delete() *NodeVersionDelete {
	mutation := newNodeVersionMutation(c.config, OpDelete)
	return &NodeVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeVersionClient) DeleteOne(nv *NodeVersion) *NodeVersionDeleteOne {
	return c.DeleteOneID(nv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeVersionClient) DeleteOneID(id uuid.UUID) *NodeVersionDeleteOne {
	builder := c.Delete().Where(nodeversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeVersionDeleteOne{builder}
}

// Query returns a query builder for NodeVersion.
func (c *NodeVersionClient) Query() *NodeVersionQuery {
	return &NodeVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNodeVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a NodeVersion entity by its id.
func (c *NodeVersionClient) Get(ctx context.Context, id uuid.UUID) (*NodeVersion, error) {
	return c.Query().Where(nodeversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeVersionClient) GetX(ctx context.Context, id uuid.UUID) *NodeVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNode queries the node edge of a NodeVersion.
func (c *NodeVersionClient) QueryNode(nv *NodeVersion) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodeversion.Table, nodeversion.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nodeversion.NodeTable, nodeversion.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(nv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStorageFile queries the storage_file edge of a NodeVersion.
func (c *NodeVersionClient) QueryStorageFile(nv *NodeVersion) *StorageFileQuery {
	query := (&StorageFileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nodeversion.Table, nodeversion.FieldID, id),
			sqlgraph.To(storagefile.Table, storagefile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, nodeversion.StorageFileTable, nodeversion.StorageFileColumn),
		)
		fromV = sqlgraph.Neighbors(nv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeVersionClient) Hooks() []Hook {
	return c.hooks.NodeVersion
}

// Interceptors returns the client interceptors.
func (c *NodeVersionClient) Interceptors() []Interceptor {
	return c.inters.NodeVersion
}

func (c *NodeVersionClient) mutate(ctx context.Context, m *NodeVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NodeVersion mutation op: %q", m.Op())
	}
}

// PersonalAccessTokenClient is a client for the PersonalAccessToken schema.
type PersonalAccessTokenClient struct {
	config
}

// NewPersonalAccessTokenClient returns a client for the PersonalAccessToken from the given config.
func NewPersonalAccessTokenClient(c config) *PersonalAccessTokenClient {
	return &PersonalAccessTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personalaccesstoken.Hooks(f(g(h())))`.
func (c *PersonalAccessTokenClient) Use(hooks ...Hook) {
	c.hooks.PersonalAccessToken = append(c.hooks.PersonalAccessToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `personalaccesstoken.Intercept(f(g(h())))`.
func (c *PersonalAccessTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PersonalAccessToken = append(c.inters.PersonalAccessToken, interceptors...)
}

// Create returns a builder for creating a PersonalAccessToken entity.
func (c *PersonalAccessTokenClient) Create() *PersonalAccessTokenCreate {
	mutation := newPersonalAccessTokenMutation(c.config, OpCreate)
	return &PersonalAccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PersonalAccessToken entities.
func (c *PersonalAccessTokenClient) CreateBulk(builders ...*PersonalAccessTokenCreate) *PersonalAccessTokenCreateBulk {
	return &PersonalAccessTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonalAccessTokenClient) MapCreateBulk(slice any, setFunc func(*PersonalAccessTokenCreate, int)) *PersonalAccessTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonalAccessTokenCreateBulk{err: fmt.Errorf("calling to PersonalAccessTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonalAccessTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonalAccessTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Update() *PersonalAccessTokenUpdate {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdate)
	return &PersonalAccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonalAccessTokenClient) UpdateOne(pat *PersonalAccessToken) *PersonalAccessTokenUpdateOne {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdateOne, withPersonalAccessToken(pat))
	return &PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonalAccessTokenClient) UpdateOneID(id uuid.UUID) *PersonalAccessTokenUpdateOne {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdateOne, withPersonalAccessTokenID(id))
	return &PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Delete() *PersonalAccessTokenDelete {
	mutation := newPersonalAccessTokenMutation(c.config, OpDelete)
	return &PersonalAccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonalAccessTokenClient) DeleteOne(pat *PersonalAccessToken) *PersonalAccessTokenDeleteOne {
	return c.DeleteOneID(pat.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonalAccessTokenClient) DeleteOneID(id uuid.UUID) *PersonalAccessTokenDeleteOne {
	builder := c.Delete().Where(personalaccesstoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonalAccessTokenDeleteOne{builder}
}

// Query returns a query builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Query() *PersonalAccessTokenQuery {
	return &PersonalAccessTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePersonalAccessToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PersonalAccessToken entity by its id.
func (c *PersonalAccessTokenClient) Get(ctx context.Context, id uuid.UUID) (*PersonalAccessToken, error) {
	return c.Query().Where(personalaccesstoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonalAccessTokenClient) GetX(ctx context.Context, id uuid.UUID) *PersonalAccessToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPublisher queries the publisher edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryPublisher(pat *PersonalAccessToken) *PublisherQuery {
	query := (&PublisherClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(publisher.Table, publisher.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personalaccesstoken.PublisherTable, personalaccesstoken.PublisherColumn),
		)
		fromV = sqlgraph.Neighbors(pat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonalAccessTokenClient) Hooks() []Hook {
	return c.hooks.PersonalAccessToken
}

// Interceptors returns the client interceptors.
func (c *PersonalAccessTokenClient) Interceptors() []Interceptor {
	return c.inters.PersonalAccessToken
}

func (c *PersonalAccessTokenClient) mutate(ctx context.Context, m *PersonalAccessTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonalAccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonalAccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonalAccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PersonalAccessToken mutation op: %q", m.Op())
	}
}

// PublisherClient is a client for the Publisher schema.
type PublisherClient struct {
	config
}

// NewPublisherClient returns a client for the Publisher from the given config.
func NewPublisherClient(c config) *PublisherClient {
	return &PublisherClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publisher.Hooks(f(g(h())))`.
func (c *PublisherClient) Use(hooks ...Hook) {
	c.hooks.Publisher = append(c.hooks.Publisher, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publisher.Intercept(f(g(h())))`.
func (c *PublisherClient) Intercept(interceptors ...Interceptor) {
	c.inters.Publisher = append(c.inters.Publisher, interceptors...)
}

// Create returns a builder for creating a Publisher entity.
func (c *PublisherClient) Create() *PublisherCreate {
	mutation := newPublisherMutation(c.config, OpCreate)
	return &PublisherCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Publisher entities.
func (c *PublisherClient) CreateBulk(builders ...*PublisherCreate) *PublisherCreateBulk {
	return &PublisherCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublisherClient) MapCreateBulk(slice any, setFunc func(*PublisherCreate, int)) *PublisherCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublisherCreateBulk{err: fmt.Errorf("calling to PublisherClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublisherCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublisherCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Publisher.
func (c *PublisherClient) Update() *PublisherUpdate {
	mutation := newPublisherMutation(c.config, OpUpdate)
	return &PublisherUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublisherClient) UpdateOne(pu *Publisher) *PublisherUpdateOne {
	mutation := newPublisherMutation(c.config, OpUpdateOne, withPublisher(pu))
	return &PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublisherClient) UpdateOneID(id string) *PublisherUpdateOne {
	mutation := newPublisherMutation(c.config, OpUpdateOne, withPublisherID(id))
	return &PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Publisher.
func (c *PublisherClient) Delete() *PublisherDelete {
	mutation := newPublisherMutation(c.config, OpDelete)
	return &PublisherDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublisherClient) DeleteOne(pu *Publisher) *PublisherDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublisherClient) DeleteOneID(id string) *PublisherDeleteOne {
	builder := c.Delete().Where(publisher.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublisherDeleteOne{builder}
}

// Query returns a query builder for Publisher.
func (c *PublisherClient) Query() *PublisherQuery {
	return &PublisherQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublisher},
		inters: c.Interceptors(),
	}
}

// Get returns a Publisher entity by its id.
func (c *PublisherClient) Get(ctx context.Context, id string) (*Publisher, error) {
	return c.Query().Where(publisher.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublisherClient) GetX(ctx context.Context, id string) *Publisher {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPublisherPermissions queries the publisher_permissions edge of a Publisher.
func (c *PublisherClient) QueryPublisherPermissions(pu *Publisher) *PublisherPermissionQuery {
	query := (&PublisherPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publisher.Table, publisher.FieldID, id),
			sqlgraph.To(publisherpermission.Table, publisherpermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, publisher.PublisherPermissionsTable, publisher.PublisherPermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Publisher.
func (c *PublisherClient) QueryNodes(pu *Publisher) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publisher.Table, publisher.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, publisher.NodesTable, publisher.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonalAccessTokens queries the personal_access_tokens edge of a Publisher.
func (c *PublisherClient) QueryPersonalAccessTokens(pu *Publisher) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publisher.Table, publisher.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, publisher.PersonalAccessTokensTable, publisher.PersonalAccessTokensColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PublisherClient) Hooks() []Hook {
	return c.hooks.Publisher
}

// Interceptors returns the client interceptors.
func (c *PublisherClient) Interceptors() []Interceptor {
	return c.inters.Publisher
}

func (c *PublisherClient) mutate(ctx context.Context, m *PublisherMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublisherCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublisherUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublisherDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Publisher mutation op: %q", m.Op())
	}
}

// PublisherPermissionClient is a client for the PublisherPermission schema.
type PublisherPermissionClient struct {
	config
}

// NewPublisherPermissionClient returns a client for the PublisherPermission from the given config.
func NewPublisherPermissionClient(c config) *PublisherPermissionClient {
	return &PublisherPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publisherpermission.Hooks(f(g(h())))`.
func (c *PublisherPermissionClient) Use(hooks ...Hook) {
	c.hooks.PublisherPermission = append(c.hooks.PublisherPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publisherpermission.Intercept(f(g(h())))`.
func (c *PublisherPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublisherPermission = append(c.inters.PublisherPermission, interceptors...)
}

// Create returns a builder for creating a PublisherPermission entity.
func (c *PublisherPermissionClient) Create() *PublisherPermissionCreate {
	mutation := newPublisherPermissionMutation(c.config, OpCreate)
	return &PublisherPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublisherPermission entities.
func (c *PublisherPermissionClient) CreateBulk(builders ...*PublisherPermissionCreate) *PublisherPermissionCreateBulk {
	return &PublisherPermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublisherPermissionClient) MapCreateBulk(slice any, setFunc func(*PublisherPermissionCreate, int)) *PublisherPermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublisherPermissionCreateBulk{err: fmt.Errorf("calling to PublisherPermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublisherPermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublisherPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublisherPermission.
func (c *PublisherPermissionClient) Update() *PublisherPermissionUpdate {
	mutation := newPublisherPermissionMutation(c.config, OpUpdate)
	return &PublisherPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublisherPermissionClient) UpdateOne(pp *PublisherPermission) *PublisherPermissionUpdateOne {
	mutation := newPublisherPermissionMutation(c.config, OpUpdateOne, withPublisherPermission(pp))
	return &PublisherPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublisherPermissionClient) UpdateOneID(id int) *PublisherPermissionUpdateOne {
	mutation := newPublisherPermissionMutation(c.config, OpUpdateOne, withPublisherPermissionID(id))
	return &PublisherPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublisherPermission.
func (c *PublisherPermissionClient) Delete() *PublisherPermissionDelete {
	mutation := newPublisherPermissionMutation(c.config, OpDelete)
	return &PublisherPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublisherPermissionClient) DeleteOne(pp *PublisherPermission) *PublisherPermissionDeleteOne {
	return c.DeleteOneID(pp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublisherPermissionClient) DeleteOneID(id int) *PublisherPermissionDeleteOne {
	builder := c.Delete().Where(publisherpermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublisherPermissionDeleteOne{builder}
}

// Query returns a query builder for PublisherPermission.
func (c *PublisherPermissionClient) Query() *PublisherPermissionQuery {
	return &PublisherPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublisherPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a PublisherPermission entity by its id.
func (c *PublisherPermissionClient) Get(ctx context.Context, id int) (*PublisherPermission, error) {
	return c.Query().Where(publisherpermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublisherPermissionClient) GetX(ctx context.Context, id int) *PublisherPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PublisherPermission.
func (c *PublisherPermissionClient) QueryUser(pp *PublisherPermission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publisherpermission.Table, publisherpermission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, publisherpermission.UserTable, publisherpermission.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPublisher queries the publisher edge of a PublisherPermission.
func (c *PublisherPermissionClient) QueryPublisher(pp *PublisherPermission) *PublisherQuery {
	query := (&PublisherClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publisherpermission.Table, publisherpermission.FieldID, id),
			sqlgraph.To(publisher.Table, publisher.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, publisherpermission.PublisherTable, publisherpermission.PublisherColumn),
		)
		fromV = sqlgraph.Neighbors(pp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PublisherPermissionClient) Hooks() []Hook {
	return c.hooks.PublisherPermission
}

// Interceptors returns the client interceptors.
func (c *PublisherPermissionClient) Interceptors() []Interceptor {
	return c.inters.PublisherPermission
}

func (c *PublisherPermissionClient) mutate(ctx context.Context, m *PublisherPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublisherPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublisherPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublisherPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublisherPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublisherPermission mutation op: %q", m.Op())
	}
}

// StorageFileClient is a client for the StorageFile schema.
type StorageFileClient struct {
	config
}

// NewStorageFileClient returns a client for the StorageFile from the given config.
func NewStorageFileClient(c config) *StorageFileClient {
	return &StorageFileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `storagefile.Hooks(f(g(h())))`.
func (c *StorageFileClient) Use(hooks ...Hook) {
	c.hooks.StorageFile = append(c.hooks.StorageFile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `storagefile.Intercept(f(g(h())))`.
func (c *StorageFileClient) Intercept(interceptors ...Interceptor) {
	c.inters.StorageFile = append(c.inters.StorageFile, interceptors...)
}

// Create returns a builder for creating a StorageFile entity.
func (c *StorageFileClient) Create() *StorageFileCreate {
	mutation := newStorageFileMutation(c.config, OpCreate)
	return &StorageFileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StorageFile entities.
func (c *StorageFileClient) CreateBulk(builders ...*StorageFileCreate) *StorageFileCreateBulk {
	return &StorageFileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StorageFileClient) MapCreateBulk(slice any, setFunc func(*StorageFileCreate, int)) *StorageFileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StorageFileCreateBulk{err: fmt.Errorf("calling to StorageFileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StorageFileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StorageFileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StorageFile.
func (c *StorageFileClient) Update() *StorageFileUpdate {
	mutation := newStorageFileMutation(c.config, OpUpdate)
	return &StorageFileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StorageFileClient) UpdateOne(sf *StorageFile) *StorageFileUpdateOne {
	mutation := newStorageFileMutation(c.config, OpUpdateOne, withStorageFile(sf))
	return &StorageFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StorageFileClient) UpdateOneID(id uuid.UUID) *StorageFileUpdateOne {
	mutation := newStorageFileMutation(c.config, OpUpdateOne, withStorageFileID(id))
	return &StorageFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StorageFile.
func (c *StorageFileClient) Delete() *StorageFileDelete {
	mutation := newStorageFileMutation(c.config, OpDelete)
	return &StorageFileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StorageFileClient) DeleteOne(sf *StorageFile) *StorageFileDeleteOne {
	return c.DeleteOneID(sf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StorageFileClient) DeleteOneID(id uuid.UUID) *StorageFileDeleteOne {
	builder := c.Delete().Where(storagefile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StorageFileDeleteOne{builder}
}

// Query returns a query builder for StorageFile.
func (c *StorageFileClient) Query() *StorageFileQuery {
	return &StorageFileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStorageFile},
		inters: c.Interceptors(),
	}
}

// Get returns a StorageFile entity by its id.
func (c *StorageFileClient) Get(ctx context.Context, id uuid.UUID) (*StorageFile, error) {
	return c.Query().Where(storagefile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StorageFileClient) GetX(ctx context.Context, id uuid.UUID) *StorageFile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StorageFileClient) Hooks() []Hook {
	return c.hooks.StorageFile
}

// Interceptors returns the client interceptors.
func (c *StorageFileClient) Interceptors() []Interceptor {
	return c.inters.StorageFile
}

func (c *StorageFileClient) mutate(ctx context.Context, m *StorageFileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StorageFileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StorageFileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StorageFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StorageFileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StorageFile mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPublisherPermissions queries the publisher_permissions edge of a User.
func (c *UserClient) QueryPublisherPermissions(u *User) *PublisherPermissionQuery {
	query := (&PublisherPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(publisherpermission.Table, publisherpermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PublisherPermissionsTable, user.PublisherPermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		CIWorkflowResult, GitCommit, Node, NodeVersion, PersonalAccessToken, Publisher,
		PublisherPermission, StorageFile, User []ent.Hook
	}
	inters struct {
		CIWorkflowResult, GitCommit, Node, NodeVersion, PersonalAccessToken, Publisher,
		PublisherPermission, StorageFile, User []ent.Interceptor
	}
)
