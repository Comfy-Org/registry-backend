// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"registry-backend/ent/ciworkflowresult"
	"registry-backend/ent/gitcommit"
	"registry-backend/ent/node"
	"registry-backend/ent/nodereview"
	"registry-backend/ent/nodeversion"
	"registry-backend/ent/personalaccesstoken"
	"registry-backend/ent/predicate"
	"registry-backend/ent/publisher"
	"registry-backend/ent/publisherpermission"
	"registry-backend/ent/schema"
	"registry-backend/ent/storagefile"
	"registry-backend/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCIWorkflowResult    = "CIWorkflowResult"
	TypeGitCommit           = "GitCommit"
	TypeNode                = "Node"
	TypeNodeReview          = "NodeReview"
	TypeNodeVersion         = "NodeVersion"
	TypePersonalAccessToken = "PersonalAccessToken"
	TypePublisher           = "Publisher"
	TypePublisherPermission = "PublisherPermission"
	TypeStorageFile         = "StorageFile"
	TypeUser                = "User"
)

// CIWorkflowResultMutation represents an operation that mutates the CIWorkflowResult nodes in the graph.
type CIWorkflowResultMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	create_time         *time.Time
	update_time         *time.Time
	operating_system    *string
	gpu_type            *string
	pytorch_version     *string
	workflow_name       *string
	run_id              *string
	status              *schema.WorkflowRunStatusType
	start_time          *int64
	addstart_time       *int64
	end_time            *int64
	addend_time         *int64
	python_version      *string
	avg_vram            *int
	addavg_vram         *int
	peak_vram           *int
	addpeak_vram        *int
	job_trigger_user    *string
	clearedFields       map[string]struct{}
	gitcommit           *uuid.UUID
	clearedgitcommit    bool
	storage_file        *uuid.UUID
	clearedstorage_file bool
	done                bool
	oldValue            func(context.Context) (*CIWorkflowResult, error)
	predicates          []predicate.CIWorkflowResult
}

var _ ent.Mutation = (*CIWorkflowResultMutation)(nil)

// ciworkflowresultOption allows management of the mutation configuration using functional options.
type ciworkflowresultOption func(*CIWorkflowResultMutation)

// newCIWorkflowResultMutation creates new mutation for the CIWorkflowResult entity.
func newCIWorkflowResultMutation(c config, op Op, opts ...ciworkflowresultOption) *CIWorkflowResultMutation {
	m := &CIWorkflowResultMutation{
		config:        c,
		op:            op,
		typ:           TypeCIWorkflowResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCIWorkflowResultID sets the ID field of the mutation.
func withCIWorkflowResultID(id uuid.UUID) ciworkflowresultOption {
	return func(m *CIWorkflowResultMutation) {
		var (
			err   error
			once  sync.Once
			value *CIWorkflowResult
		)
		m.oldValue = func(ctx context.Context) (*CIWorkflowResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CIWorkflowResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCIWorkflowResult sets the old CIWorkflowResult of the mutation.
func withCIWorkflowResult(node *CIWorkflowResult) ciworkflowresultOption {
	return func(m *CIWorkflowResultMutation) {
		m.oldValue = func(context.Context) (*CIWorkflowResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CIWorkflowResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CIWorkflowResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CIWorkflowResult entities.
func (m *CIWorkflowResultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CIWorkflowResultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CIWorkflowResultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CIWorkflowResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CIWorkflowResultMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CIWorkflowResultMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CIWorkflowResultMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CIWorkflowResultMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CIWorkflowResultMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CIWorkflowResultMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOperatingSystem sets the "operating_system" field.
func (m *CIWorkflowResultMutation) SetOperatingSystem(s string) {
	m.operating_system = &s
}

// OperatingSystem returns the value of the "operating_system" field in the mutation.
func (m *CIWorkflowResultMutation) OperatingSystem() (r string, exists bool) {
	v := m.operating_system
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatingSystem returns the old "operating_system" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldOperatingSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatingSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatingSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatingSystem: %w", err)
	}
	return oldValue.OperatingSystem, nil
}

// ResetOperatingSystem resets all changes to the "operating_system" field.
func (m *CIWorkflowResultMutation) ResetOperatingSystem() {
	m.operating_system = nil
}

// SetGpuType sets the "gpu_type" field.
func (m *CIWorkflowResultMutation) SetGpuType(s string) {
	m.gpu_type = &s
}

// GpuType returns the value of the "gpu_type" field in the mutation.
func (m *CIWorkflowResultMutation) GpuType() (r string, exists bool) {
	v := m.gpu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuType returns the old "gpu_type" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldGpuType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuType: %w", err)
	}
	return oldValue.GpuType, nil
}

// ClearGpuType clears the value of the "gpu_type" field.
func (m *CIWorkflowResultMutation) ClearGpuType() {
	m.gpu_type = nil
	m.clearedFields[ciworkflowresult.FieldGpuType] = struct{}{}
}

// GpuTypeCleared returns if the "gpu_type" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) GpuTypeCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldGpuType]
	return ok
}

// ResetGpuType resets all changes to the "gpu_type" field.
func (m *CIWorkflowResultMutation) ResetGpuType() {
	m.gpu_type = nil
	delete(m.clearedFields, ciworkflowresult.FieldGpuType)
}

// SetPytorchVersion sets the "pytorch_version" field.
func (m *CIWorkflowResultMutation) SetPytorchVersion(s string) {
	m.pytorch_version = &s
}

// PytorchVersion returns the value of the "pytorch_version" field in the mutation.
func (m *CIWorkflowResultMutation) PytorchVersion() (r string, exists bool) {
	v := m.pytorch_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPytorchVersion returns the old "pytorch_version" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldPytorchVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPytorchVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPytorchVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPytorchVersion: %w", err)
	}
	return oldValue.PytorchVersion, nil
}

// ClearPytorchVersion clears the value of the "pytorch_version" field.
func (m *CIWorkflowResultMutation) ClearPytorchVersion() {
	m.pytorch_version = nil
	m.clearedFields[ciworkflowresult.FieldPytorchVersion] = struct{}{}
}

// PytorchVersionCleared returns if the "pytorch_version" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) PytorchVersionCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldPytorchVersion]
	return ok
}

// ResetPytorchVersion resets all changes to the "pytorch_version" field.
func (m *CIWorkflowResultMutation) ResetPytorchVersion() {
	m.pytorch_version = nil
	delete(m.clearedFields, ciworkflowresult.FieldPytorchVersion)
}

// SetWorkflowName sets the "workflow_name" field.
func (m *CIWorkflowResultMutation) SetWorkflowName(s string) {
	m.workflow_name = &s
}

// WorkflowName returns the value of the "workflow_name" field in the mutation.
func (m *CIWorkflowResultMutation) WorkflowName() (r string, exists bool) {
	v := m.workflow_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowName returns the old "workflow_name" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldWorkflowName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowName: %w", err)
	}
	return oldValue.WorkflowName, nil
}

// ClearWorkflowName clears the value of the "workflow_name" field.
func (m *CIWorkflowResultMutation) ClearWorkflowName() {
	m.workflow_name = nil
	m.clearedFields[ciworkflowresult.FieldWorkflowName] = struct{}{}
}

// WorkflowNameCleared returns if the "workflow_name" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) WorkflowNameCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldWorkflowName]
	return ok
}

// ResetWorkflowName resets all changes to the "workflow_name" field.
func (m *CIWorkflowResultMutation) ResetWorkflowName() {
	m.workflow_name = nil
	delete(m.clearedFields, ciworkflowresult.FieldWorkflowName)
}

// SetRunID sets the "run_id" field.
func (m *CIWorkflowResultMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *CIWorkflowResultMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ClearRunID clears the value of the "run_id" field.
func (m *CIWorkflowResultMutation) ClearRunID() {
	m.run_id = nil
	m.clearedFields[ciworkflowresult.FieldRunID] = struct{}{}
}

// RunIDCleared returns if the "run_id" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) RunIDCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldRunID]
	return ok
}

// ResetRunID resets all changes to the "run_id" field.
func (m *CIWorkflowResultMutation) ResetRunID() {
	m.run_id = nil
	delete(m.clearedFields, ciworkflowresult.FieldRunID)
}

// SetStatus sets the "status" field.
func (m *CIWorkflowResultMutation) SetStatus(srst schema.WorkflowRunStatusType) {
	m.status = &srst
}

// Status returns the value of the "status" field in the mutation.
func (m *CIWorkflowResultMutation) Status() (r schema.WorkflowRunStatusType, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldStatus(ctx context.Context) (v schema.WorkflowRunStatusType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CIWorkflowResultMutation) ResetStatus() {
	m.status = nil
}

// SetStartTime sets the "start_time" field.
func (m *CIWorkflowResultMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CIWorkflowResultMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *CIWorkflowResultMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *CIWorkflowResultMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartTime clears the value of the "start_time" field.
func (m *CIWorkflowResultMutation) ClearStartTime() {
	m.start_time = nil
	m.addstart_time = nil
	m.clearedFields[ciworkflowresult.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CIWorkflowResultMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
	delete(m.clearedFields, ciworkflowresult.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *CIWorkflowResultMutation) SetEndTime(i int64) {
	m.end_time = &i
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CIWorkflowResultMutation) EndTime() (r int64, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldEndTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds i to the "end_time" field.
func (m *CIWorkflowResultMutation) AddEndTime(i int64) {
	if m.addend_time != nil {
		*m.addend_time += i
	} else {
		m.addend_time = &i
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *CIWorkflowResultMutation) AddedEndTime() (r int64, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndTime clears the value of the "end_time" field.
func (m *CIWorkflowResultMutation) ClearEndTime() {
	m.end_time = nil
	m.addend_time = nil
	m.clearedFields[ciworkflowresult.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CIWorkflowResultMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
	delete(m.clearedFields, ciworkflowresult.FieldEndTime)
}

// SetPythonVersion sets the "python_version" field.
func (m *CIWorkflowResultMutation) SetPythonVersion(s string) {
	m.python_version = &s
}

// PythonVersion returns the value of the "python_version" field in the mutation.
func (m *CIWorkflowResultMutation) PythonVersion() (r string, exists bool) {
	v := m.python_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPythonVersion returns the old "python_version" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldPythonVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPythonVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPythonVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPythonVersion: %w", err)
	}
	return oldValue.PythonVersion, nil
}

// ClearPythonVersion clears the value of the "python_version" field.
func (m *CIWorkflowResultMutation) ClearPythonVersion() {
	m.python_version = nil
	m.clearedFields[ciworkflowresult.FieldPythonVersion] = struct{}{}
}

// PythonVersionCleared returns if the "python_version" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) PythonVersionCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldPythonVersion]
	return ok
}

// ResetPythonVersion resets all changes to the "python_version" field.
func (m *CIWorkflowResultMutation) ResetPythonVersion() {
	m.python_version = nil
	delete(m.clearedFields, ciworkflowresult.FieldPythonVersion)
}

// SetAvgVram sets the "avg_vram" field.
func (m *CIWorkflowResultMutation) SetAvgVram(i int) {
	m.avg_vram = &i
	m.addavg_vram = nil
}

// AvgVram returns the value of the "avg_vram" field in the mutation.
func (m *CIWorkflowResultMutation) AvgVram() (r int, exists bool) {
	v := m.avg_vram
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgVram returns the old "avg_vram" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldAvgVram(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgVram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgVram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgVram: %w", err)
	}
	return oldValue.AvgVram, nil
}

// AddAvgVram adds i to the "avg_vram" field.
func (m *CIWorkflowResultMutation) AddAvgVram(i int) {
	if m.addavg_vram != nil {
		*m.addavg_vram += i
	} else {
		m.addavg_vram = &i
	}
}

// AddedAvgVram returns the value that was added to the "avg_vram" field in this mutation.
func (m *CIWorkflowResultMutation) AddedAvgVram() (r int, exists bool) {
	v := m.addavg_vram
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvgVram clears the value of the "avg_vram" field.
func (m *CIWorkflowResultMutation) ClearAvgVram() {
	m.avg_vram = nil
	m.addavg_vram = nil
	m.clearedFields[ciworkflowresult.FieldAvgVram] = struct{}{}
}

// AvgVramCleared returns if the "avg_vram" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) AvgVramCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldAvgVram]
	return ok
}

// ResetAvgVram resets all changes to the "avg_vram" field.
func (m *CIWorkflowResultMutation) ResetAvgVram() {
	m.avg_vram = nil
	m.addavg_vram = nil
	delete(m.clearedFields, ciworkflowresult.FieldAvgVram)
}

// SetPeakVram sets the "peak_vram" field.
func (m *CIWorkflowResultMutation) SetPeakVram(i int) {
	m.peak_vram = &i
	m.addpeak_vram = nil
}

// PeakVram returns the value of the "peak_vram" field in the mutation.
func (m *CIWorkflowResultMutation) PeakVram() (r int, exists bool) {
	v := m.peak_vram
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakVram returns the old "peak_vram" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldPeakVram(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakVram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakVram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakVram: %w", err)
	}
	return oldValue.PeakVram, nil
}

// AddPeakVram adds i to the "peak_vram" field.
func (m *CIWorkflowResultMutation) AddPeakVram(i int) {
	if m.addpeak_vram != nil {
		*m.addpeak_vram += i
	} else {
		m.addpeak_vram = &i
	}
}

// AddedPeakVram returns the value that was added to the "peak_vram" field in this mutation.
func (m *CIWorkflowResultMutation) AddedPeakVram() (r int, exists bool) {
	v := m.addpeak_vram
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakVram clears the value of the "peak_vram" field.
func (m *CIWorkflowResultMutation) ClearPeakVram() {
	m.peak_vram = nil
	m.addpeak_vram = nil
	m.clearedFields[ciworkflowresult.FieldPeakVram] = struct{}{}
}

// PeakVramCleared returns if the "peak_vram" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) PeakVramCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldPeakVram]
	return ok
}

// ResetPeakVram resets all changes to the "peak_vram" field.
func (m *CIWorkflowResultMutation) ResetPeakVram() {
	m.peak_vram = nil
	m.addpeak_vram = nil
	delete(m.clearedFields, ciworkflowresult.FieldPeakVram)
}

// SetJobTriggerUser sets the "job_trigger_user" field.
func (m *CIWorkflowResultMutation) SetJobTriggerUser(s string) {
	m.job_trigger_user = &s
}

// JobTriggerUser returns the value of the "job_trigger_user" field in the mutation.
func (m *CIWorkflowResultMutation) JobTriggerUser() (r string, exists bool) {
	v := m.job_trigger_user
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTriggerUser returns the old "job_trigger_user" field's value of the CIWorkflowResult entity.
// If the CIWorkflowResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CIWorkflowResultMutation) OldJobTriggerUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTriggerUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTriggerUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTriggerUser: %w", err)
	}
	return oldValue.JobTriggerUser, nil
}

// ClearJobTriggerUser clears the value of the "job_trigger_user" field.
func (m *CIWorkflowResultMutation) ClearJobTriggerUser() {
	m.job_trigger_user = nil
	m.clearedFields[ciworkflowresult.FieldJobTriggerUser] = struct{}{}
}

// JobTriggerUserCleared returns if the "job_trigger_user" field was cleared in this mutation.
func (m *CIWorkflowResultMutation) JobTriggerUserCleared() bool {
	_, ok := m.clearedFields[ciworkflowresult.FieldJobTriggerUser]
	return ok
}

// ResetJobTriggerUser resets all changes to the "job_trigger_user" field.
func (m *CIWorkflowResultMutation) ResetJobTriggerUser() {
	m.job_trigger_user = nil
	delete(m.clearedFields, ciworkflowresult.FieldJobTriggerUser)
}

// SetGitcommitID sets the "gitcommit" edge to the GitCommit entity by id.
func (m *CIWorkflowResultMutation) SetGitcommitID(id uuid.UUID) {
	m.gitcommit = &id
}

// ClearGitcommit clears the "gitcommit" edge to the GitCommit entity.
func (m *CIWorkflowResultMutation) ClearGitcommit() {
	m.clearedgitcommit = true
}

// GitcommitCleared reports if the "gitcommit" edge to the GitCommit entity was cleared.
func (m *CIWorkflowResultMutation) GitcommitCleared() bool {
	return m.clearedgitcommit
}

// GitcommitID returns the "gitcommit" edge ID in the mutation.
func (m *CIWorkflowResultMutation) GitcommitID() (id uuid.UUID, exists bool) {
	if m.gitcommit != nil {
		return *m.gitcommit, true
	}
	return
}

// GitcommitIDs returns the "gitcommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GitcommitID instead. It exists only for internal usage by the builders.
func (m *CIWorkflowResultMutation) GitcommitIDs() (ids []uuid.UUID) {
	if id := m.gitcommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGitcommit resets all changes to the "gitcommit" edge.
func (m *CIWorkflowResultMutation) ResetGitcommit() {
	m.gitcommit = nil
	m.clearedgitcommit = false
}

// SetStorageFileID sets the "storage_file" edge to the StorageFile entity by id.
func (m *CIWorkflowResultMutation) SetStorageFileID(id uuid.UUID) {
	m.storage_file = &id
}

// ClearStorageFile clears the "storage_file" edge to the StorageFile entity.
func (m *CIWorkflowResultMutation) ClearStorageFile() {
	m.clearedstorage_file = true
}

// StorageFileCleared reports if the "storage_file" edge to the StorageFile entity was cleared.
func (m *CIWorkflowResultMutation) StorageFileCleared() bool {
	return m.clearedstorage_file
}

// StorageFileID returns the "storage_file" edge ID in the mutation.
func (m *CIWorkflowResultMutation) StorageFileID() (id uuid.UUID, exists bool) {
	if m.storage_file != nil {
		return *m.storage_file, true
	}
	return
}

// StorageFileIDs returns the "storage_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageFileID instead. It exists only for internal usage by the builders.
func (m *CIWorkflowResultMutation) StorageFileIDs() (ids []uuid.UUID) {
	if id := m.storage_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorageFile resets all changes to the "storage_file" edge.
func (m *CIWorkflowResultMutation) ResetStorageFile() {
	m.storage_file = nil
	m.clearedstorage_file = false
}

// Where appends a list predicates to the CIWorkflowResultMutation builder.
func (m *CIWorkflowResultMutation) Where(ps ...predicate.CIWorkflowResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CIWorkflowResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CIWorkflowResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CIWorkflowResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CIWorkflowResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CIWorkflowResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CIWorkflowResult).
func (m *CIWorkflowResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CIWorkflowResultMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, ciworkflowresult.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ciworkflowresult.FieldUpdateTime)
	}
	if m.operating_system != nil {
		fields = append(fields, ciworkflowresult.FieldOperatingSystem)
	}
	if m.gpu_type != nil {
		fields = append(fields, ciworkflowresult.FieldGpuType)
	}
	if m.pytorch_version != nil {
		fields = append(fields, ciworkflowresult.FieldPytorchVersion)
	}
	if m.workflow_name != nil {
		fields = append(fields, ciworkflowresult.FieldWorkflowName)
	}
	if m.run_id != nil {
		fields = append(fields, ciworkflowresult.FieldRunID)
	}
	if m.status != nil {
		fields = append(fields, ciworkflowresult.FieldStatus)
	}
	if m.start_time != nil {
		fields = append(fields, ciworkflowresult.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, ciworkflowresult.FieldEndTime)
	}
	if m.python_version != nil {
		fields = append(fields, ciworkflowresult.FieldPythonVersion)
	}
	if m.avg_vram != nil {
		fields = append(fields, ciworkflowresult.FieldAvgVram)
	}
	if m.peak_vram != nil {
		fields = append(fields, ciworkflowresult.FieldPeakVram)
	}
	if m.job_trigger_user != nil {
		fields = append(fields, ciworkflowresult.FieldJobTriggerUser)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CIWorkflowResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ciworkflowresult.FieldCreateTime:
		return m.CreateTime()
	case ciworkflowresult.FieldUpdateTime:
		return m.UpdateTime()
	case ciworkflowresult.FieldOperatingSystem:
		return m.OperatingSystem()
	case ciworkflowresult.FieldGpuType:
		return m.GpuType()
	case ciworkflowresult.FieldPytorchVersion:
		return m.PytorchVersion()
	case ciworkflowresult.FieldWorkflowName:
		return m.WorkflowName()
	case ciworkflowresult.FieldRunID:
		return m.RunID()
	case ciworkflowresult.FieldStatus:
		return m.Status()
	case ciworkflowresult.FieldStartTime:
		return m.StartTime()
	case ciworkflowresult.FieldEndTime:
		return m.EndTime()
	case ciworkflowresult.FieldPythonVersion:
		return m.PythonVersion()
	case ciworkflowresult.FieldAvgVram:
		return m.AvgVram()
	case ciworkflowresult.FieldPeakVram:
		return m.PeakVram()
	case ciworkflowresult.FieldJobTriggerUser:
		return m.JobTriggerUser()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CIWorkflowResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ciworkflowresult.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ciworkflowresult.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ciworkflowresult.FieldOperatingSystem:
		return m.OldOperatingSystem(ctx)
	case ciworkflowresult.FieldGpuType:
		return m.OldGpuType(ctx)
	case ciworkflowresult.FieldPytorchVersion:
		return m.OldPytorchVersion(ctx)
	case ciworkflowresult.FieldWorkflowName:
		return m.OldWorkflowName(ctx)
	case ciworkflowresult.FieldRunID:
		return m.OldRunID(ctx)
	case ciworkflowresult.FieldStatus:
		return m.OldStatus(ctx)
	case ciworkflowresult.FieldStartTime:
		return m.OldStartTime(ctx)
	case ciworkflowresult.FieldEndTime:
		return m.OldEndTime(ctx)
	case ciworkflowresult.FieldPythonVersion:
		return m.OldPythonVersion(ctx)
	case ciworkflowresult.FieldAvgVram:
		return m.OldAvgVram(ctx)
	case ciworkflowresult.FieldPeakVram:
		return m.OldPeakVram(ctx)
	case ciworkflowresult.FieldJobTriggerUser:
		return m.OldJobTriggerUser(ctx)
	}
	return nil, fmt.Errorf("unknown CIWorkflowResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIWorkflowResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ciworkflowresult.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ciworkflowresult.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ciworkflowresult.FieldOperatingSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatingSystem(v)
		return nil
	case ciworkflowresult.FieldGpuType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuType(v)
		return nil
	case ciworkflowresult.FieldPytorchVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPytorchVersion(v)
		return nil
	case ciworkflowresult.FieldWorkflowName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowName(v)
		return nil
	case ciworkflowresult.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case ciworkflowresult.FieldStatus:
		v, ok := value.(schema.WorkflowRunStatusType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ciworkflowresult.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case ciworkflowresult.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case ciworkflowresult.FieldPythonVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPythonVersion(v)
		return nil
	case ciworkflowresult.FieldAvgVram:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgVram(v)
		return nil
	case ciworkflowresult.FieldPeakVram:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakVram(v)
		return nil
	case ciworkflowresult.FieldJobTriggerUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTriggerUser(v)
		return nil
	}
	return fmt.Errorf("unknown CIWorkflowResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CIWorkflowResultMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time != nil {
		fields = append(fields, ciworkflowresult.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, ciworkflowresult.FieldEndTime)
	}
	if m.addavg_vram != nil {
		fields = append(fields, ciworkflowresult.FieldAvgVram)
	}
	if m.addpeak_vram != nil {
		fields = append(fields, ciworkflowresult.FieldPeakVram)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CIWorkflowResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ciworkflowresult.FieldStartTime:
		return m.AddedStartTime()
	case ciworkflowresult.FieldEndTime:
		return m.AddedEndTime()
	case ciworkflowresult.FieldAvgVram:
		return m.AddedAvgVram()
	case ciworkflowresult.FieldPeakVram:
		return m.AddedPeakVram()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CIWorkflowResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ciworkflowresult.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case ciworkflowresult.FieldEndTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	case ciworkflowresult.FieldAvgVram:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgVram(v)
		return nil
	case ciworkflowresult.FieldPeakVram:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakVram(v)
		return nil
	}
	return fmt.Errorf("unknown CIWorkflowResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CIWorkflowResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ciworkflowresult.FieldGpuType) {
		fields = append(fields, ciworkflowresult.FieldGpuType)
	}
	if m.FieldCleared(ciworkflowresult.FieldPytorchVersion) {
		fields = append(fields, ciworkflowresult.FieldPytorchVersion)
	}
	if m.FieldCleared(ciworkflowresult.FieldWorkflowName) {
		fields = append(fields, ciworkflowresult.FieldWorkflowName)
	}
	if m.FieldCleared(ciworkflowresult.FieldRunID) {
		fields = append(fields, ciworkflowresult.FieldRunID)
	}
	if m.FieldCleared(ciworkflowresult.FieldStartTime) {
		fields = append(fields, ciworkflowresult.FieldStartTime)
	}
	if m.FieldCleared(ciworkflowresult.FieldEndTime) {
		fields = append(fields, ciworkflowresult.FieldEndTime)
	}
	if m.FieldCleared(ciworkflowresult.FieldPythonVersion) {
		fields = append(fields, ciworkflowresult.FieldPythonVersion)
	}
	if m.FieldCleared(ciworkflowresult.FieldAvgVram) {
		fields = append(fields, ciworkflowresult.FieldAvgVram)
	}
	if m.FieldCleared(ciworkflowresult.FieldPeakVram) {
		fields = append(fields, ciworkflowresult.FieldPeakVram)
	}
	if m.FieldCleared(ciworkflowresult.FieldJobTriggerUser) {
		fields = append(fields, ciworkflowresult.FieldJobTriggerUser)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CIWorkflowResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CIWorkflowResultMutation) ClearField(name string) error {
	switch name {
	case ciworkflowresult.FieldGpuType:
		m.ClearGpuType()
		return nil
	case ciworkflowresult.FieldPytorchVersion:
		m.ClearPytorchVersion()
		return nil
	case ciworkflowresult.FieldWorkflowName:
		m.ClearWorkflowName()
		return nil
	case ciworkflowresult.FieldRunID:
		m.ClearRunID()
		return nil
	case ciworkflowresult.FieldStartTime:
		m.ClearStartTime()
		return nil
	case ciworkflowresult.FieldEndTime:
		m.ClearEndTime()
		return nil
	case ciworkflowresult.FieldPythonVersion:
		m.ClearPythonVersion()
		return nil
	case ciworkflowresult.FieldAvgVram:
		m.ClearAvgVram()
		return nil
	case ciworkflowresult.FieldPeakVram:
		m.ClearPeakVram()
		return nil
	case ciworkflowresult.FieldJobTriggerUser:
		m.ClearJobTriggerUser()
		return nil
	}
	return fmt.Errorf("unknown CIWorkflowResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CIWorkflowResultMutation) ResetField(name string) error {
	switch name {
	case ciworkflowresult.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ciworkflowresult.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ciworkflowresult.FieldOperatingSystem:
		m.ResetOperatingSystem()
		return nil
	case ciworkflowresult.FieldGpuType:
		m.ResetGpuType()
		return nil
	case ciworkflowresult.FieldPytorchVersion:
		m.ResetPytorchVersion()
		return nil
	case ciworkflowresult.FieldWorkflowName:
		m.ResetWorkflowName()
		return nil
	case ciworkflowresult.FieldRunID:
		m.ResetRunID()
		return nil
	case ciworkflowresult.FieldStatus:
		m.ResetStatus()
		return nil
	case ciworkflowresult.FieldStartTime:
		m.ResetStartTime()
		return nil
	case ciworkflowresult.FieldEndTime:
		m.ResetEndTime()
		return nil
	case ciworkflowresult.FieldPythonVersion:
		m.ResetPythonVersion()
		return nil
	case ciworkflowresult.FieldAvgVram:
		m.ResetAvgVram()
		return nil
	case ciworkflowresult.FieldPeakVram:
		m.ResetPeakVram()
		return nil
	case ciworkflowresult.FieldJobTriggerUser:
		m.ResetJobTriggerUser()
		return nil
	}
	return fmt.Errorf("unknown CIWorkflowResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CIWorkflowResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.gitcommit != nil {
		edges = append(edges, ciworkflowresult.EdgeGitcommit)
	}
	if m.storage_file != nil {
		edges = append(edges, ciworkflowresult.EdgeStorageFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CIWorkflowResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ciworkflowresult.EdgeGitcommit:
		if id := m.gitcommit; id != nil {
			return []ent.Value{*id}
		}
	case ciworkflowresult.EdgeStorageFile:
		if id := m.storage_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CIWorkflowResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CIWorkflowResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CIWorkflowResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgitcommit {
		edges = append(edges, ciworkflowresult.EdgeGitcommit)
	}
	if m.clearedstorage_file {
		edges = append(edges, ciworkflowresult.EdgeStorageFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CIWorkflowResultMutation) EdgeCleared(name string) bool {
	switch name {
	case ciworkflowresult.EdgeGitcommit:
		return m.clearedgitcommit
	case ciworkflowresult.EdgeStorageFile:
		return m.clearedstorage_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CIWorkflowResultMutation) ClearEdge(name string) error {
	switch name {
	case ciworkflowresult.EdgeGitcommit:
		m.ClearGitcommit()
		return nil
	case ciworkflowresult.EdgeStorageFile:
		m.ClearStorageFile()
		return nil
	}
	return fmt.Errorf("unknown CIWorkflowResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CIWorkflowResultMutation) ResetEdge(name string) error {
	switch name {
	case ciworkflowresult.EdgeGitcommit:
		m.ResetGitcommit()
		return nil
	case ciworkflowresult.EdgeStorageFile:
		m.ResetStorageFile()
		return nil
	}
	return fmt.Errorf("unknown CIWorkflowResult edge %s", name)
}

// GitCommitMutation represents an operation that mutates the GitCommit nodes in the graph.
type GitCommitMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	commit_hash      *string
	branch_name      *string
	repo_name        *string
	commit_message   *string
	commit_timestamp *time.Time
	author           *string
	timestamp        *time.Time
	pr_number        *string
	clearedFields    map[string]struct{}
	results          map[uuid.UUID]struct{}
	removedresults   map[uuid.UUID]struct{}
	clearedresults   bool
	done             bool
	oldValue         func(context.Context) (*GitCommit, error)
	predicates       []predicate.GitCommit
}

var _ ent.Mutation = (*GitCommitMutation)(nil)

// gitcommitOption allows management of the mutation configuration using functional options.
type gitcommitOption func(*GitCommitMutation)

// newGitCommitMutation creates new mutation for the GitCommit entity.
func newGitCommitMutation(c config, op Op, opts ...gitcommitOption) *GitCommitMutation {
	m := &GitCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeGitCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitCommitID sets the ID field of the mutation.
func withGitCommitID(id uuid.UUID) gitcommitOption {
	return func(m *GitCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *GitCommit
		)
		m.oldValue = func(ctx context.Context) (*GitCommit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitCommit sets the old GitCommit of the mutation.
func withGitCommit(node *GitCommit) gitcommitOption {
	return func(m *GitCommitMutation) {
		m.oldValue = func(context.Context) (*GitCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GitCommit entities.
func (m *GitCommitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitCommitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GitCommitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GitCommit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *GitCommitMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GitCommitMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GitCommitMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GitCommitMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GitCommitMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GitCommitMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCommitHash sets the "commit_hash" field.
func (m *GitCommitMutation) SetCommitHash(s string) {
	m.commit_hash = &s
}

// CommitHash returns the value of the "commit_hash" field in the mutation.
func (m *GitCommitMutation) CommitHash() (r string, exists bool) {
	v := m.commit_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitHash returns the old "commit_hash" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldCommitHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitHash: %w", err)
	}
	return oldValue.CommitHash, nil
}

// ResetCommitHash resets all changes to the "commit_hash" field.
func (m *GitCommitMutation) ResetCommitHash() {
	m.commit_hash = nil
}

// SetBranchName sets the "branch_name" field.
func (m *GitCommitMutation) SetBranchName(s string) {
	m.branch_name = &s
}

// BranchName returns the value of the "branch_name" field in the mutation.
func (m *GitCommitMutation) BranchName() (r string, exists bool) {
	v := m.branch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchName returns the old "branch_name" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldBranchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchName: %w", err)
	}
	return oldValue.BranchName, nil
}

// ResetBranchName resets all changes to the "branch_name" field.
func (m *GitCommitMutation) ResetBranchName() {
	m.branch_name = nil
}

// SetRepoName sets the "repo_name" field.
func (m *GitCommitMutation) SetRepoName(s string) {
	m.repo_name = &s
}

// RepoName returns the value of the "repo_name" field in the mutation.
func (m *GitCommitMutation) RepoName() (r string, exists bool) {
	v := m.repo_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoName returns the old "repo_name" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldRepoName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoName: %w", err)
	}
	return oldValue.RepoName, nil
}

// ResetRepoName resets all changes to the "repo_name" field.
func (m *GitCommitMutation) ResetRepoName() {
	m.repo_name = nil
}

// SetCommitMessage sets the "commit_message" field.
func (m *GitCommitMutation) SetCommitMessage(s string) {
	m.commit_message = &s
}

// CommitMessage returns the value of the "commit_message" field in the mutation.
func (m *GitCommitMutation) CommitMessage() (r string, exists bool) {
	v := m.commit_message
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitMessage returns the old "commit_message" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldCommitMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitMessage: %w", err)
	}
	return oldValue.CommitMessage, nil
}

// ResetCommitMessage resets all changes to the "commit_message" field.
func (m *GitCommitMutation) ResetCommitMessage() {
	m.commit_message = nil
}

// SetCommitTimestamp sets the "commit_timestamp" field.
func (m *GitCommitMutation) SetCommitTimestamp(t time.Time) {
	m.commit_timestamp = &t
}

// CommitTimestamp returns the value of the "commit_timestamp" field in the mutation.
func (m *GitCommitMutation) CommitTimestamp() (r time.Time, exists bool) {
	v := m.commit_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitTimestamp returns the old "commit_timestamp" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldCommitTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitTimestamp: %w", err)
	}
	return oldValue.CommitTimestamp, nil
}

// ResetCommitTimestamp resets all changes to the "commit_timestamp" field.
func (m *GitCommitMutation) ResetCommitTimestamp() {
	m.commit_timestamp = nil
}

// SetAuthor sets the "author" field.
func (m *GitCommitMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *GitCommitMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *GitCommitMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[gitcommit.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *GitCommitMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[gitcommit.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *GitCommitMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, gitcommit.FieldAuthor)
}

// SetTimestamp sets the "timestamp" field.
func (m *GitCommitMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *GitCommitMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ClearTimestamp clears the value of the "timestamp" field.
func (m *GitCommitMutation) ClearTimestamp() {
	m.timestamp = nil
	m.clearedFields[gitcommit.FieldTimestamp] = struct{}{}
}

// TimestampCleared returns if the "timestamp" field was cleared in this mutation.
func (m *GitCommitMutation) TimestampCleared() bool {
	_, ok := m.clearedFields[gitcommit.FieldTimestamp]
	return ok
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *GitCommitMutation) ResetTimestamp() {
	m.timestamp = nil
	delete(m.clearedFields, gitcommit.FieldTimestamp)
}

// SetPrNumber sets the "pr_number" field.
func (m *GitCommitMutation) SetPrNumber(s string) {
	m.pr_number = &s
}

// PrNumber returns the value of the "pr_number" field in the mutation.
func (m *GitCommitMutation) PrNumber() (r string, exists bool) {
	v := m.pr_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPrNumber returns the old "pr_number" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldPrNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrNumber: %w", err)
	}
	return oldValue.PrNumber, nil
}

// ClearPrNumber clears the value of the "pr_number" field.
func (m *GitCommitMutation) ClearPrNumber() {
	m.pr_number = nil
	m.clearedFields[gitcommit.FieldPrNumber] = struct{}{}
}

// PrNumberCleared returns if the "pr_number" field was cleared in this mutation.
func (m *GitCommitMutation) PrNumberCleared() bool {
	_, ok := m.clearedFields[gitcommit.FieldPrNumber]
	return ok
}

// ResetPrNumber resets all changes to the "pr_number" field.
func (m *GitCommitMutation) ResetPrNumber() {
	m.pr_number = nil
	delete(m.clearedFields, gitcommit.FieldPrNumber)
}

// AddResultIDs adds the "results" edge to the CIWorkflowResult entity by ids.
func (m *GitCommitMutation) AddResultIDs(ids ...uuid.UUID) {
	if m.results == nil {
		m.results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the CIWorkflowResult entity.
func (m *GitCommitMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the CIWorkflowResult entity was cleared.
func (m *GitCommitMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the CIWorkflowResult entity by IDs.
func (m *GitCommitMutation) RemoveResultIDs(ids ...uuid.UUID) {
	if m.removedresults == nil {
		m.removedresults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the CIWorkflowResult entity.
func (m *GitCommitMutation) RemovedResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *GitCommitMutation) ResultsIDs() (ids []uuid.UUID) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *GitCommitMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// Where appends a list predicates to the GitCommitMutation builder.
func (m *GitCommitMutation) Where(ps ...predicate.GitCommit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GitCommitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GitCommitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GitCommit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GitCommitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GitCommitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GitCommit).
func (m *GitCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitCommitMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, gitcommit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, gitcommit.FieldUpdateTime)
	}
	if m.commit_hash != nil {
		fields = append(fields, gitcommit.FieldCommitHash)
	}
	if m.branch_name != nil {
		fields = append(fields, gitcommit.FieldBranchName)
	}
	if m.repo_name != nil {
		fields = append(fields, gitcommit.FieldRepoName)
	}
	if m.commit_message != nil {
		fields = append(fields, gitcommit.FieldCommitMessage)
	}
	if m.commit_timestamp != nil {
		fields = append(fields, gitcommit.FieldCommitTimestamp)
	}
	if m.author != nil {
		fields = append(fields, gitcommit.FieldAuthor)
	}
	if m.timestamp != nil {
		fields = append(fields, gitcommit.FieldTimestamp)
	}
	if m.pr_number != nil {
		fields = append(fields, gitcommit.FieldPrNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gitcommit.FieldCreateTime:
		return m.CreateTime()
	case gitcommit.FieldUpdateTime:
		return m.UpdateTime()
	case gitcommit.FieldCommitHash:
		return m.CommitHash()
	case gitcommit.FieldBranchName:
		return m.BranchName()
	case gitcommit.FieldRepoName:
		return m.RepoName()
	case gitcommit.FieldCommitMessage:
		return m.CommitMessage()
	case gitcommit.FieldCommitTimestamp:
		return m.CommitTimestamp()
	case gitcommit.FieldAuthor:
		return m.Author()
	case gitcommit.FieldTimestamp:
		return m.Timestamp()
	case gitcommit.FieldPrNumber:
		return m.PrNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gitcommit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case gitcommit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case gitcommit.FieldCommitHash:
		return m.OldCommitHash(ctx)
	case gitcommit.FieldBranchName:
		return m.OldBranchName(ctx)
	case gitcommit.FieldRepoName:
		return m.OldRepoName(ctx)
	case gitcommit.FieldCommitMessage:
		return m.OldCommitMessage(ctx)
	case gitcommit.FieldCommitTimestamp:
		return m.OldCommitTimestamp(ctx)
	case gitcommit.FieldAuthor:
		return m.OldAuthor(ctx)
	case gitcommit.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case gitcommit.FieldPrNumber:
		return m.OldPrNumber(ctx)
	}
	return nil, fmt.Errorf("unknown GitCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gitcommit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case gitcommit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case gitcommit.FieldCommitHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitHash(v)
		return nil
	case gitcommit.FieldBranchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchName(v)
		return nil
	case gitcommit.FieldRepoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoName(v)
		return nil
	case gitcommit.FieldCommitMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitMessage(v)
		return nil
	case gitcommit.FieldCommitTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitTimestamp(v)
		return nil
	case gitcommit.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case gitcommit.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case gitcommit.FieldPrNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrNumber(v)
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitCommitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitCommitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GitCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitCommitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gitcommit.FieldAuthor) {
		fields = append(fields, gitcommit.FieldAuthor)
	}
	if m.FieldCleared(gitcommit.FieldTimestamp) {
		fields = append(fields, gitcommit.FieldTimestamp)
	}
	if m.FieldCleared(gitcommit.FieldPrNumber) {
		fields = append(fields, gitcommit.FieldPrNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitCommitMutation) ClearField(name string) error {
	switch name {
	case gitcommit.FieldAuthor:
		m.ClearAuthor()
		return nil
	case gitcommit.FieldTimestamp:
		m.ClearTimestamp()
		return nil
	case gitcommit.FieldPrNumber:
		m.ClearPrNumber()
		return nil
	}
	return fmt.Errorf("unknown GitCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitCommitMutation) ResetField(name string) error {
	switch name {
	case gitcommit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case gitcommit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case gitcommit.FieldCommitHash:
		m.ResetCommitHash()
		return nil
	case gitcommit.FieldBranchName:
		m.ResetBranchName()
		return nil
	case gitcommit.FieldRepoName:
		m.ResetRepoName()
		return nil
	case gitcommit.FieldCommitMessage:
		m.ResetCommitMessage()
		return nil
	case gitcommit.FieldCommitTimestamp:
		m.ResetCommitTimestamp()
		return nil
	case gitcommit.FieldAuthor:
		m.ResetAuthor()
		return nil
	case gitcommit.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case gitcommit.FieldPrNumber:
		m.ResetPrNumber()
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.results != nil {
		edges = append(edges, gitcommit.EdgeResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gitcommit.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresults != nil {
		edges = append(edges, gitcommit.EdgeResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gitcommit.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresults {
		edges = append(edges, gitcommit.EdgeResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case gitcommit.EdgeResults:
		return m.clearedresults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitCommitMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GitCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitCommitMutation) ResetEdge(name string) error {
	switch name {
	case gitcommit.EdgeResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown GitCommit edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op               Op
	typ              string
	id               *string
	create_time      *time.Time
	update_time      *time.Time
	name             *string
	description      *string
	category         *string
	author           *string
	license          *string
	repository_url   *string
	icon_url         *string
	tags             *[]string
	appendtags       []string
	total_install    *int64
	addtotal_install *int64
	total_star       *int64
	addtotal_star    *int64
	total_review     *int64
	addtotal_review  *int64
	status           *schema.NodeStatus
	status_detail    *string
	clearedFields    map[string]struct{}
	publisher        *string
	clearedpublisher bool
	versions         map[uuid.UUID]struct{}
	removedversions  map[uuid.UUID]struct{}
	clearedversions  bool
	reviews          map[uuid.UUID]struct{}
	removedreviews   map[uuid.UUID]struct{}
	clearedreviews   bool
	done             bool
	oldValue         func(context.Context) (*Node, error)
	predicates       []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id string) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *NodeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *NodeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *NodeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *NodeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *NodeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *NodeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPublisherID sets the "publisher_id" field.
func (m *NodeMutation) SetPublisherID(s string) {
	m.publisher = &s
}

// PublisherID returns the value of the "publisher_id" field in the mutation.
func (m *NodeMutation) PublisherID() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherID returns the old "publisher_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPublisherID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherID: %w", err)
	}
	return oldValue.PublisherID, nil
}

// ResetPublisherID resets all changes to the "publisher_id" field.
func (m *NodeMutation) ResetPublisherID() {
	m.publisher = nil
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[node.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[node.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, node.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *NodeMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *NodeMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *NodeMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[node.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *NodeMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[node.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *NodeMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, node.FieldCategory)
}

// SetAuthor sets the "author" field.
func (m *NodeMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *NodeMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *NodeMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[node.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *NodeMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[node.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *NodeMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, node.FieldAuthor)
}

// SetLicense sets the "license" field.
func (m *NodeMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *NodeMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ResetLicense resets all changes to the "license" field.
func (m *NodeMutation) ResetLicense() {
	m.license = nil
}

// SetRepositoryURL sets the "repository_url" field.
func (m *NodeMutation) SetRepositoryURL(s string) {
	m.repository_url = &s
}

// RepositoryURL returns the value of the "repository_url" field in the mutation.
func (m *NodeMutation) RepositoryURL() (r string, exists bool) {
	v := m.repository_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryURL returns the old "repository_url" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldRepositoryURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryURL: %w", err)
	}
	return oldValue.RepositoryURL, nil
}

// ResetRepositoryURL resets all changes to the "repository_url" field.
func (m *NodeMutation) ResetRepositoryURL() {
	m.repository_url = nil
}

// SetIconURL sets the "icon_url" field.
func (m *NodeMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *NodeMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *NodeMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[node.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *NodeMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[node.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *NodeMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, node.FieldIconURL)
}

// SetTags sets the "tags" field.
func (m *NodeMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NodeMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NodeMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NodeMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *NodeMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetTotalInstall sets the "total_install" field.
func (m *NodeMutation) SetTotalInstall(i int64) {
	m.total_install = &i
	m.addtotal_install = nil
}

// TotalInstall returns the value of the "total_install" field in the mutation.
func (m *NodeMutation) TotalInstall() (r int64, exists bool) {
	v := m.total_install
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalInstall returns the old "total_install" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldTotalInstall(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalInstall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalInstall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalInstall: %w", err)
	}
	return oldValue.TotalInstall, nil
}

// AddTotalInstall adds i to the "total_install" field.
func (m *NodeMutation) AddTotalInstall(i int64) {
	if m.addtotal_install != nil {
		*m.addtotal_install += i
	} else {
		m.addtotal_install = &i
	}
}

// AddedTotalInstall returns the value that was added to the "total_install" field in this mutation.
func (m *NodeMutation) AddedTotalInstall() (r int64, exists bool) {
	v := m.addtotal_install
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalInstall resets all changes to the "total_install" field.
func (m *NodeMutation) ResetTotalInstall() {
	m.total_install = nil
	m.addtotal_install = nil
}

// SetTotalStar sets the "total_star" field.
func (m *NodeMutation) SetTotalStar(i int64) {
	m.total_star = &i
	m.addtotal_star = nil
}

// TotalStar returns the value of the "total_star" field in the mutation.
func (m *NodeMutation) TotalStar() (r int64, exists bool) {
	v := m.total_star
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalStar returns the old "total_star" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldTotalStar(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalStar: %w", err)
	}
	return oldValue.TotalStar, nil
}

// AddTotalStar adds i to the "total_star" field.
func (m *NodeMutation) AddTotalStar(i int64) {
	if m.addtotal_star != nil {
		*m.addtotal_star += i
	} else {
		m.addtotal_star = &i
	}
}

// AddedTotalStar returns the value that was added to the "total_star" field in this mutation.
func (m *NodeMutation) AddedTotalStar() (r int64, exists bool) {
	v := m.addtotal_star
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalStar resets all changes to the "total_star" field.
func (m *NodeMutation) ResetTotalStar() {
	m.total_star = nil
	m.addtotal_star = nil
}

// SetTotalReview sets the "total_review" field.
func (m *NodeMutation) SetTotalReview(i int64) {
	m.total_review = &i
	m.addtotal_review = nil
}

// TotalReview returns the value of the "total_review" field in the mutation.
func (m *NodeMutation) TotalReview() (r int64, exists bool) {
	v := m.total_review
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalReview returns the old "total_review" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldTotalReview(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalReview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalReview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalReview: %w", err)
	}
	return oldValue.TotalReview, nil
}

// AddTotalReview adds i to the "total_review" field.
func (m *NodeMutation) AddTotalReview(i int64) {
	if m.addtotal_review != nil {
		*m.addtotal_review += i
	} else {
		m.addtotal_review = &i
	}
}

// AddedTotalReview returns the value that was added to the "total_review" field in this mutation.
func (m *NodeMutation) AddedTotalReview() (r int64, exists bool) {
	v := m.addtotal_review
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalReview resets all changes to the "total_review" field.
func (m *NodeMutation) ResetTotalReview() {
	m.total_review = nil
	m.addtotal_review = nil
}

// SetStatus sets the "status" field.
func (m *NodeMutation) SetStatus(ss schema.NodeStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *NodeMutation) Status() (r schema.NodeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStatus(ctx context.Context) (v schema.NodeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NodeMutation) ResetStatus() {
	m.status = nil
}

// SetStatusDetail sets the "status_detail" field.
func (m *NodeMutation) SetStatusDetail(s string) {
	m.status_detail = &s
}

// StatusDetail returns the value of the "status_detail" field in the mutation.
func (m *NodeMutation) StatusDetail() (r string, exists bool) {
	v := m.status_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDetail returns the old "status_detail" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStatusDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDetail: %w", err)
	}
	return oldValue.StatusDetail, nil
}

// ClearStatusDetail clears the value of the "status_detail" field.
func (m *NodeMutation) ClearStatusDetail() {
	m.status_detail = nil
	m.clearedFields[node.FieldStatusDetail] = struct{}{}
}

// StatusDetailCleared returns if the "status_detail" field was cleared in this mutation.
func (m *NodeMutation) StatusDetailCleared() bool {
	_, ok := m.clearedFields[node.FieldStatusDetail]
	return ok
}

// ResetStatusDetail resets all changes to the "status_detail" field.
func (m *NodeMutation) ResetStatusDetail() {
	m.status_detail = nil
	delete(m.clearedFields, node.FieldStatusDetail)
}

// ClearPublisher clears the "publisher" edge to the Publisher entity.
func (m *NodeMutation) ClearPublisher() {
	m.clearedpublisher = true
	m.clearedFields[node.FieldPublisherID] = struct{}{}
}

// PublisherCleared reports if the "publisher" edge to the Publisher entity was cleared.
func (m *NodeMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublisherID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) PublisherIDs() (ids []string) {
	if id := m.publisher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *NodeMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
}

// AddVersionIDs adds the "versions" edge to the NodeVersion entity by ids.
func (m *NodeMutation) AddVersionIDs(ids ...uuid.UUID) {
	if m.versions == nil {
		m.versions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the NodeVersion entity.
func (m *NodeMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the NodeVersion entity was cleared.
func (m *NodeMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the NodeVersion entity by IDs.
func (m *NodeMutation) RemoveVersionIDs(ids ...uuid.UUID) {
	if m.removedversions == nil {
		m.removedversions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the NodeVersion entity.
func (m *NodeMutation) RemovedVersionsIDs() (ids []uuid.UUID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *NodeMutation) VersionsIDs() (ids []uuid.UUID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *NodeMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddReviewIDs adds the "reviews" edge to the NodeReview entity by ids.
func (m *NodeMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.reviews == nil {
		m.reviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the NodeReview entity.
func (m *NodeMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the NodeReview entity was cleared.
func (m *NodeMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the NodeReview entity by IDs.
func (m *NodeMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the NodeReview entity.
func (m *NodeMutation) RemovedReviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *NodeMutation) ReviewsIDs() (ids []uuid.UUID) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *NodeMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, node.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, node.FieldUpdateTime)
	}
	if m.publisher != nil {
		fields = append(fields, node.FieldPublisherID)
	}
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, node.FieldCategory)
	}
	if m.author != nil {
		fields = append(fields, node.FieldAuthor)
	}
	if m.license != nil {
		fields = append(fields, node.FieldLicense)
	}
	if m.repository_url != nil {
		fields = append(fields, node.FieldRepositoryURL)
	}
	if m.icon_url != nil {
		fields = append(fields, node.FieldIconURL)
	}
	if m.tags != nil {
		fields = append(fields, node.FieldTags)
	}
	if m.total_install != nil {
		fields = append(fields, node.FieldTotalInstall)
	}
	if m.total_star != nil {
		fields = append(fields, node.FieldTotalStar)
	}
	if m.total_review != nil {
		fields = append(fields, node.FieldTotalReview)
	}
	if m.status != nil {
		fields = append(fields, node.FieldStatus)
	}
	if m.status_detail != nil {
		fields = append(fields, node.FieldStatusDetail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldCreateTime:
		return m.CreateTime()
	case node.FieldUpdateTime:
		return m.UpdateTime()
	case node.FieldPublisherID:
		return m.PublisherID()
	case node.FieldName:
		return m.Name()
	case node.FieldDescription:
		return m.Description()
	case node.FieldCategory:
		return m.Category()
	case node.FieldAuthor:
		return m.Author()
	case node.FieldLicense:
		return m.License()
	case node.FieldRepositoryURL:
		return m.RepositoryURL()
	case node.FieldIconURL:
		return m.IconURL()
	case node.FieldTags:
		return m.Tags()
	case node.FieldTotalInstall:
		return m.TotalInstall()
	case node.FieldTotalStar:
		return m.TotalStar()
	case node.FieldTotalReview:
		return m.TotalReview()
	case node.FieldStatus:
		return m.Status()
	case node.FieldStatusDetail:
		return m.StatusDetail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case node.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case node.FieldPublisherID:
		return m.OldPublisherID(ctx)
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldCategory:
		return m.OldCategory(ctx)
	case node.FieldAuthor:
		return m.OldAuthor(ctx)
	case node.FieldLicense:
		return m.OldLicense(ctx)
	case node.FieldRepositoryURL:
		return m.OldRepositoryURL(ctx)
	case node.FieldIconURL:
		return m.OldIconURL(ctx)
	case node.FieldTags:
		return m.OldTags(ctx)
	case node.FieldTotalInstall:
		return m.OldTotalInstall(ctx)
	case node.FieldTotalStar:
		return m.OldTotalStar(ctx)
	case node.FieldTotalReview:
		return m.OldTotalReview(ctx)
	case node.FieldStatus:
		return m.OldStatus(ctx)
	case node.FieldStatusDetail:
		return m.OldStatusDetail(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case node.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case node.FieldPublisherID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherID(v)
		return nil
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case node.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case node.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case node.FieldRepositoryURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryURL(v)
		return nil
	case node.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case node.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case node.FieldTotalInstall:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalInstall(v)
		return nil
	case node.FieldTotalStar:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalStar(v)
		return nil
	case node.FieldTotalReview:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalReview(v)
		return nil
	case node.FieldStatus:
		v, ok := value.(schema.NodeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case node.FieldStatusDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDetail(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_install != nil {
		fields = append(fields, node.FieldTotalInstall)
	}
	if m.addtotal_star != nil {
		fields = append(fields, node.FieldTotalStar)
	}
	if m.addtotal_review != nil {
		fields = append(fields, node.FieldTotalReview)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case node.FieldTotalInstall:
		return m.AddedTotalInstall()
	case node.FieldTotalStar:
		return m.AddedTotalStar()
	case node.FieldTotalReview:
		return m.AddedTotalReview()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case node.FieldTotalInstall:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalInstall(v)
		return nil
	case node.FieldTotalStar:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalStar(v)
		return nil
	case node.FieldTotalReview:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalReview(v)
		return nil
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldDescription) {
		fields = append(fields, node.FieldDescription)
	}
	if m.FieldCleared(node.FieldCategory) {
		fields = append(fields, node.FieldCategory)
	}
	if m.FieldCleared(node.FieldAuthor) {
		fields = append(fields, node.FieldAuthor)
	}
	if m.FieldCleared(node.FieldIconURL) {
		fields = append(fields, node.FieldIconURL)
	}
	if m.FieldCleared(node.FieldStatusDetail) {
		fields = append(fields, node.FieldStatusDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldDescription:
		m.ClearDescription()
		return nil
	case node.FieldCategory:
		m.ClearCategory()
		return nil
	case node.FieldAuthor:
		m.ClearAuthor()
		return nil
	case node.FieldIconURL:
		m.ClearIconURL()
		return nil
	case node.FieldStatusDetail:
		m.ClearStatusDetail()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case node.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case node.FieldPublisherID:
		m.ResetPublisherID()
		return nil
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldCategory:
		m.ResetCategory()
		return nil
	case node.FieldAuthor:
		m.ResetAuthor()
		return nil
	case node.FieldLicense:
		m.ResetLicense()
		return nil
	case node.FieldRepositoryURL:
		m.ResetRepositoryURL()
		return nil
	case node.FieldIconURL:
		m.ResetIconURL()
		return nil
	case node.FieldTags:
		m.ResetTags()
		return nil
	case node.FieldTotalInstall:
		m.ResetTotalInstall()
		return nil
	case node.FieldTotalStar:
		m.ResetTotalStar()
		return nil
	case node.FieldTotalReview:
		m.ResetTotalReview()
		return nil
	case node.FieldStatus:
		m.ResetStatus()
		return nil
	case node.FieldStatusDetail:
		m.ResetStatusDetail()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.publisher != nil {
		edges = append(edges, node.EdgePublisher)
	}
	if m.versions != nil {
		edges = append(edges, node.EdgeVersions)
	}
	if m.reviews != nil {
		edges = append(edges, node.EdgeReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgePublisher:
		if id := m.publisher; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedversions != nil {
		edges = append(edges, node.EdgeVersions)
	}
	if m.removedreviews != nil {
		edges = append(edges, node.EdgeReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpublisher {
		edges = append(edges, node.EdgePublisher)
	}
	if m.clearedversions {
		edges = append(edges, node.EdgeVersions)
	}
	if m.clearedreviews {
		edges = append(edges, node.EdgeReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgePublisher:
		return m.clearedpublisher
	case node.EdgeVersions:
		return m.clearedversions
	case node.EdgeReviews:
		return m.clearedreviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	case node.EdgePublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgePublisher:
		m.ResetPublisher()
		return nil
	case node.EdgeVersions:
		m.ResetVersions()
		return nil
	case node.EdgeReviews:
		m.ResetReviews()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// NodeReviewMutation represents an operation that mutates the NodeReview nodes in the graph.
type NodeReviewMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	star          *int
	addstar       *int
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	node          *string
	clearednode   bool
	done          bool
	oldValue      func(context.Context) (*NodeReview, error)
	predicates    []predicate.NodeReview
}

var _ ent.Mutation = (*NodeReviewMutation)(nil)

// nodereviewOption allows management of the mutation configuration using functional options.
type nodereviewOption func(*NodeReviewMutation)

// newNodeReviewMutation creates new mutation for the NodeReview entity.
func newNodeReviewMutation(c config, op Op, opts ...nodereviewOption) *NodeReviewMutation {
	m := &NodeReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeNodeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeReviewID sets the ID field of the mutation.
func withNodeReviewID(id uuid.UUID) nodereviewOption {
	return func(m *NodeReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *NodeReview
		)
		m.oldValue = func(ctx context.Context) (*NodeReview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NodeReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNodeReview sets the old NodeReview of the mutation.
func withNodeReview(node *NodeReview) nodereviewOption {
	return func(m *NodeReviewMutation) {
		m.oldValue = func(context.Context) (*NodeReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NodeReview entities.
func (m *NodeReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NodeReview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *NodeReviewMutation) SetNodeID(s string) {
	m.node = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *NodeReviewMutation) NodeID() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the NodeReview entity.
// If the NodeReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeReviewMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *NodeReviewMutation) ResetNodeID() {
	m.node = nil
}

// SetUserID sets the "user_id" field.
func (m *NodeReviewMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NodeReviewMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the NodeReview entity.
// If the NodeReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeReviewMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NodeReviewMutation) ResetUserID() {
	m.user = nil
}

// SetStar sets the "star" field.
func (m *NodeReviewMutation) SetStar(i int) {
	m.star = &i
	m.addstar = nil
}

// Star returns the value of the "star" field in the mutation.
func (m *NodeReviewMutation) Star() (r int, exists bool) {
	v := m.star
	if v == nil {
		return
	}
	return *v, true
}

// OldStar returns the old "star" field's value of the NodeReview entity.
// If the NodeReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeReviewMutation) OldStar(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStar: %w", err)
	}
	return oldValue.Star, nil
}

// AddStar adds i to the "star" field.
func (m *NodeReviewMutation) AddStar(i int) {
	if m.addstar != nil {
		*m.addstar += i
	} else {
		m.addstar = &i
	}
}

// AddedStar returns the value that was added to the "star" field in this mutation.
func (m *NodeReviewMutation) AddedStar() (r int, exists bool) {
	v := m.addstar
	if v == nil {
		return
	}
	return *v, true
}

// ResetStar resets all changes to the "star" field.
func (m *NodeReviewMutation) ResetStar() {
	m.star = nil
	m.addstar = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *NodeReviewMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[nodereview.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NodeReviewMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NodeReviewMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NodeReviewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearNode clears the "node" edge to the Node entity.
func (m *NodeReviewMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[nodereview.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *NodeReviewMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *NodeReviewMutation) NodeIDs() (ids []string) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *NodeReviewMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the NodeReviewMutation builder.
func (m *NodeReviewMutation) Where(ps ...predicate.NodeReview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NodeReview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NodeReview).
func (m *NodeReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeReviewMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.node != nil {
		fields = append(fields, nodereview.FieldNodeID)
	}
	if m.user != nil {
		fields = append(fields, nodereview.FieldUserID)
	}
	if m.star != nil {
		fields = append(fields, nodereview.FieldStar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nodereview.FieldNodeID:
		return m.NodeID()
	case nodereview.FieldUserID:
		return m.UserID()
	case nodereview.FieldStar:
		return m.Star()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nodereview.FieldNodeID:
		return m.OldNodeID(ctx)
	case nodereview.FieldUserID:
		return m.OldUserID(ctx)
	case nodereview.FieldStar:
		return m.OldStar(ctx)
	}
	return nil, fmt.Errorf("unknown NodeReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nodereview.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case nodereview.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case nodereview.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStar(v)
		return nil
	}
	return fmt.Errorf("unknown NodeReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeReviewMutation) AddedFields() []string {
	var fields []string
	if m.addstar != nil {
		fields = append(fields, nodereview.FieldStar)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nodereview.FieldStar:
		return m.AddedStar()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nodereview.FieldStar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStar(v)
		return nil
	}
	return fmt.Errorf("unknown NodeReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NodeReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeReviewMutation) ResetField(name string) error {
	switch name {
	case nodereview.FieldNodeID:
		m.ResetNodeID()
		return nil
	case nodereview.FieldUserID:
		m.ResetUserID()
		return nil
	case nodereview.FieldStar:
		m.ResetStar()
		return nil
	}
	return fmt.Errorf("unknown NodeReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, nodereview.EdgeUser)
	}
	if m.node != nil {
		edges = append(edges, nodereview.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nodereview.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case nodereview.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, nodereview.EdgeUser)
	}
	if m.clearednode {
		edges = append(edges, nodereview.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case nodereview.EdgeUser:
		return m.cleareduser
	case nodereview.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeReviewMutation) ClearEdge(name string) error {
	switch name {
	case nodereview.EdgeUser:
		m.ClearUser()
		return nil
	case nodereview.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown NodeReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeReviewMutation) ResetEdge(name string) error {
	switch name {
	case nodereview.EdgeUser:
		m.ResetUser()
		return nil
	case nodereview.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown NodeReview edge %s", name)
}

// NodeVersionMutation represents an operation that mutates the NodeVersion nodes in the graph.
type NodeVersionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	version                *string
	changelog              *string
	pip_dependencies       *[]string
	appendpip_dependencies []string
	deprecated             *bool
	status                 *schema.NodeVersionStatus
	status_reason          *string
	clearedFields          map[string]struct{}
	node                   *string
	clearednode            bool
	storage_file           *uuid.UUID
	clearedstorage_file    bool
	done                   bool
	oldValue               func(context.Context) (*NodeVersion, error)
	predicates             []predicate.NodeVersion
}

var _ ent.Mutation = (*NodeVersionMutation)(nil)

// nodeversionOption allows management of the mutation configuration using functional options.
type nodeversionOption func(*NodeVersionMutation)

// newNodeVersionMutation creates new mutation for the NodeVersion entity.
func newNodeVersionMutation(c config, op Op, opts ...nodeversionOption) *NodeVersionMutation {
	m := &NodeVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeNodeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeVersionID sets the ID field of the mutation.
func withNodeVersionID(id uuid.UUID) nodeversionOption {
	return func(m *NodeVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *NodeVersion
		)
		m.oldValue = func(ctx context.Context) (*NodeVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NodeVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNodeVersion sets the old NodeVersion of the mutation.
func withNodeVersion(node *NodeVersion) nodeversionOption {
	return func(m *NodeVersionMutation) {
		m.oldValue = func(context.Context) (*NodeVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NodeVersion entities.
func (m *NodeVersionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeVersionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeVersionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NodeVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *NodeVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *NodeVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *NodeVersionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *NodeVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *NodeVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *NodeVersionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNodeID sets the "node_id" field.
func (m *NodeVersionMutation) SetNodeID(s string) {
	m.node = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *NodeVersionMutation) NodeID() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *NodeVersionMutation) ResetNodeID() {
	m.node = nil
}

// SetVersion sets the "version" field.
func (m *NodeVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *NodeVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *NodeVersionMutation) ResetVersion() {
	m.version = nil
}

// SetChangelog sets the "changelog" field.
func (m *NodeVersionMutation) SetChangelog(s string) {
	m.changelog = &s
}

// Changelog returns the value of the "changelog" field in the mutation.
func (m *NodeVersionMutation) Changelog() (r string, exists bool) {
	v := m.changelog
	if v == nil {
		return
	}
	return *v, true
}

// OldChangelog returns the old "changelog" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldChangelog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangelog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangelog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangelog: %w", err)
	}
	return oldValue.Changelog, nil
}

// ClearChangelog clears the value of the "changelog" field.
func (m *NodeVersionMutation) ClearChangelog() {
	m.changelog = nil
	m.clearedFields[nodeversion.FieldChangelog] = struct{}{}
}

// ChangelogCleared returns if the "changelog" field was cleared in this mutation.
func (m *NodeVersionMutation) ChangelogCleared() bool {
	_, ok := m.clearedFields[nodeversion.FieldChangelog]
	return ok
}

// ResetChangelog resets all changes to the "changelog" field.
func (m *NodeVersionMutation) ResetChangelog() {
	m.changelog = nil
	delete(m.clearedFields, nodeversion.FieldChangelog)
}

// SetPipDependencies sets the "pip_dependencies" field.
func (m *NodeVersionMutation) SetPipDependencies(s []string) {
	m.pip_dependencies = &s
	m.appendpip_dependencies = nil
}

// PipDependencies returns the value of the "pip_dependencies" field in the mutation.
func (m *NodeVersionMutation) PipDependencies() (r []string, exists bool) {
	v := m.pip_dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldPipDependencies returns the old "pip_dependencies" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldPipDependencies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPipDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPipDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPipDependencies: %w", err)
	}
	return oldValue.PipDependencies, nil
}

// AppendPipDependencies adds s to the "pip_dependencies" field.
func (m *NodeVersionMutation) AppendPipDependencies(s []string) {
	m.appendpip_dependencies = append(m.appendpip_dependencies, s...)
}

// AppendedPipDependencies returns the list of values that were appended to the "pip_dependencies" field in this mutation.
func (m *NodeVersionMutation) AppendedPipDependencies() ([]string, bool) {
	if len(m.appendpip_dependencies) == 0 {
		return nil, false
	}
	return m.appendpip_dependencies, true
}

// ResetPipDependencies resets all changes to the "pip_dependencies" field.
func (m *NodeVersionMutation) ResetPipDependencies() {
	m.pip_dependencies = nil
	m.appendpip_dependencies = nil
}

// SetDeprecated sets the "deprecated" field.
func (m *NodeVersionMutation) SetDeprecated(b bool) {
	m.deprecated = &b
}

// Deprecated returns the value of the "deprecated" field in the mutation.
func (m *NodeVersionMutation) Deprecated() (r bool, exists bool) {
	v := m.deprecated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeprecated returns the old "deprecated" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldDeprecated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeprecated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeprecated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeprecated: %w", err)
	}
	return oldValue.Deprecated, nil
}

// ResetDeprecated resets all changes to the "deprecated" field.
func (m *NodeVersionMutation) ResetDeprecated() {
	m.deprecated = nil
}

// SetStatus sets the "status" field.
func (m *NodeVersionMutation) SetStatus(svs schema.NodeVersionStatus) {
	m.status = &svs
}

// Status returns the value of the "status" field in the mutation.
func (m *NodeVersionMutation) Status() (r schema.NodeVersionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldStatus(ctx context.Context) (v schema.NodeVersionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NodeVersionMutation) ResetStatus() {
	m.status = nil
}

// SetStatusReason sets the "status_reason" field.
func (m *NodeVersionMutation) SetStatusReason(s string) {
	m.status_reason = &s
}

// StatusReason returns the value of the "status_reason" field in the mutation.
func (m *NodeVersionMutation) StatusReason() (r string, exists bool) {
	v := m.status_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusReason returns the old "status_reason" field's value of the NodeVersion entity.
// If the NodeVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeVersionMutation) OldStatusReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusReason: %w", err)
	}
	return oldValue.StatusReason, nil
}

// ResetStatusReason resets all changes to the "status_reason" field.
func (m *NodeVersionMutation) ResetStatusReason() {
	m.status_reason = nil
}

// ClearNode clears the "node" edge to the Node entity.
func (m *NodeVersionMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[nodeversion.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *NodeVersionMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *NodeVersionMutation) NodeIDs() (ids []string) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *NodeVersionMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// SetStorageFileID sets the "storage_file" edge to the StorageFile entity by id.
func (m *NodeVersionMutation) SetStorageFileID(id uuid.UUID) {
	m.storage_file = &id
}

// ClearStorageFile clears the "storage_file" edge to the StorageFile entity.
func (m *NodeVersionMutation) ClearStorageFile() {
	m.clearedstorage_file = true
}

// StorageFileCleared reports if the "storage_file" edge to the StorageFile entity was cleared.
func (m *NodeVersionMutation) StorageFileCleared() bool {
	return m.clearedstorage_file
}

// StorageFileID returns the "storage_file" edge ID in the mutation.
func (m *NodeVersionMutation) StorageFileID() (id uuid.UUID, exists bool) {
	if m.storage_file != nil {
		return *m.storage_file, true
	}
	return
}

// StorageFileIDs returns the "storage_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageFileID instead. It exists only for internal usage by the builders.
func (m *NodeVersionMutation) StorageFileIDs() (ids []uuid.UUID) {
	if id := m.storage_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorageFile resets all changes to the "storage_file" edge.
func (m *NodeVersionMutation) ResetStorageFile() {
	m.storage_file = nil
	m.clearedstorage_file = false
}

// Where appends a list predicates to the NodeVersionMutation builder.
func (m *NodeVersionMutation) Where(ps ...predicate.NodeVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NodeVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NodeVersion).
func (m *NodeVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, nodeversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, nodeversion.FieldUpdateTime)
	}
	if m.node != nil {
		fields = append(fields, nodeversion.FieldNodeID)
	}
	if m.version != nil {
		fields = append(fields, nodeversion.FieldVersion)
	}
	if m.changelog != nil {
		fields = append(fields, nodeversion.FieldChangelog)
	}
	if m.pip_dependencies != nil {
		fields = append(fields, nodeversion.FieldPipDependencies)
	}
	if m.deprecated != nil {
		fields = append(fields, nodeversion.FieldDeprecated)
	}
	if m.status != nil {
		fields = append(fields, nodeversion.FieldStatus)
	}
	if m.status_reason != nil {
		fields = append(fields, nodeversion.FieldStatusReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nodeversion.FieldCreateTime:
		return m.CreateTime()
	case nodeversion.FieldUpdateTime:
		return m.UpdateTime()
	case nodeversion.FieldNodeID:
		return m.NodeID()
	case nodeversion.FieldVersion:
		return m.Version()
	case nodeversion.FieldChangelog:
		return m.Changelog()
	case nodeversion.FieldPipDependencies:
		return m.PipDependencies()
	case nodeversion.FieldDeprecated:
		return m.Deprecated()
	case nodeversion.FieldStatus:
		return m.Status()
	case nodeversion.FieldStatusReason:
		return m.StatusReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nodeversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case nodeversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case nodeversion.FieldNodeID:
		return m.OldNodeID(ctx)
	case nodeversion.FieldVersion:
		return m.OldVersion(ctx)
	case nodeversion.FieldChangelog:
		return m.OldChangelog(ctx)
	case nodeversion.FieldPipDependencies:
		return m.OldPipDependencies(ctx)
	case nodeversion.FieldDeprecated:
		return m.OldDeprecated(ctx)
	case nodeversion.FieldStatus:
		return m.OldStatus(ctx)
	case nodeversion.FieldStatusReason:
		return m.OldStatusReason(ctx)
	}
	return nil, fmt.Errorf("unknown NodeVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nodeversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case nodeversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case nodeversion.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case nodeversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case nodeversion.FieldChangelog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangelog(v)
		return nil
	case nodeversion.FieldPipDependencies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPipDependencies(v)
		return nil
	case nodeversion.FieldDeprecated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeprecated(v)
		return nil
	case nodeversion.FieldStatus:
		v, ok := value.(schema.NodeVersionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case nodeversion.FieldStatusReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusReason(v)
		return nil
	}
	return fmt.Errorf("unknown NodeVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NodeVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nodeversion.FieldChangelog) {
		fields = append(fields, nodeversion.FieldChangelog)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeVersionMutation) ClearField(name string) error {
	switch name {
	case nodeversion.FieldChangelog:
		m.ClearChangelog()
		return nil
	}
	return fmt.Errorf("unknown NodeVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeVersionMutation) ResetField(name string) error {
	switch name {
	case nodeversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case nodeversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case nodeversion.FieldNodeID:
		m.ResetNodeID()
		return nil
	case nodeversion.FieldVersion:
		m.ResetVersion()
		return nil
	case nodeversion.FieldChangelog:
		m.ResetChangelog()
		return nil
	case nodeversion.FieldPipDependencies:
		m.ResetPipDependencies()
		return nil
	case nodeversion.FieldDeprecated:
		m.ResetDeprecated()
		return nil
	case nodeversion.FieldStatus:
		m.ResetStatus()
		return nil
	case nodeversion.FieldStatusReason:
		m.ResetStatusReason()
		return nil
	}
	return fmt.Errorf("unknown NodeVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.node != nil {
		edges = append(edges, nodeversion.EdgeNode)
	}
	if m.storage_file != nil {
		edges = append(edges, nodeversion.EdgeStorageFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nodeversion.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	case nodeversion.EdgeStorageFile:
		if id := m.storage_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednode {
		edges = append(edges, nodeversion.EdgeNode)
	}
	if m.clearedstorage_file {
		edges = append(edges, nodeversion.EdgeStorageFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case nodeversion.EdgeNode:
		return m.clearednode
	case nodeversion.EdgeStorageFile:
		return m.clearedstorage_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeVersionMutation) ClearEdge(name string) error {
	switch name {
	case nodeversion.EdgeNode:
		m.ClearNode()
		return nil
	case nodeversion.EdgeStorageFile:
		m.ClearStorageFile()
		return nil
	}
	return fmt.Errorf("unknown NodeVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeVersionMutation) ResetEdge(name string) error {
	switch name {
	case nodeversion.EdgeNode:
		m.ResetNode()
		return nil
	case nodeversion.EdgeStorageFile:
		m.ResetStorageFile()
		return nil
	}
	return fmt.Errorf("unknown NodeVersion edge %s", name)
}

// PersonalAccessTokenMutation represents an operation that mutates the PersonalAccessToken nodes in the graph.
type PersonalAccessTokenMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	name             *string
	description      *string
	token            *string
	clearedFields    map[string]struct{}
	publisher        *string
	clearedpublisher bool
	done             bool
	oldValue         func(context.Context) (*PersonalAccessToken, error)
	predicates       []predicate.PersonalAccessToken
}

var _ ent.Mutation = (*PersonalAccessTokenMutation)(nil)

// personalaccesstokenOption allows management of the mutation configuration using functional options.
type personalaccesstokenOption func(*PersonalAccessTokenMutation)

// newPersonalAccessTokenMutation creates new mutation for the PersonalAccessToken entity.
func newPersonalAccessTokenMutation(c config, op Op, opts ...personalaccesstokenOption) *PersonalAccessTokenMutation {
	m := &PersonalAccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalAccessTokenID sets the ID field of the mutation.
func withPersonalAccessTokenID(id uuid.UUID) personalaccesstokenOption {
	return func(m *PersonalAccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalAccessToken
		)
		m.oldValue = func(ctx context.Context) (*PersonalAccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalAccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalAccessToken sets the old PersonalAccessToken of the mutation.
func withPersonalAccessToken(node *PersonalAccessToken) personalaccesstokenOption {
	return func(m *PersonalAccessTokenMutation) {
		m.oldValue = func(context.Context) (*PersonalAccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalAccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalAccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalAccessToken entities.
func (m *PersonalAccessTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalAccessTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalAccessTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalAccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PersonalAccessTokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PersonalAccessTokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PersonalAccessTokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PersonalAccessTokenMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PersonalAccessTokenMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PersonalAccessTokenMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *PersonalAccessTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonalAccessTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonalAccessTokenMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PersonalAccessTokenMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PersonalAccessTokenMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PersonalAccessTokenMutation) ResetDescription() {
	m.description = nil
}

// SetPublisherID sets the "publisher_id" field.
func (m *PersonalAccessTokenMutation) SetPublisherID(s string) {
	m.publisher = &s
}

// PublisherID returns the value of the "publisher_id" field in the mutation.
func (m *PersonalAccessTokenMutation) PublisherID() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherID returns the old "publisher_id" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldPublisherID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherID: %w", err)
	}
	return oldValue.PublisherID, nil
}

// ResetPublisherID resets all changes to the "publisher_id" field.
func (m *PersonalAccessTokenMutation) ResetPublisherID() {
	m.publisher = nil
}

// SetToken sets the "token" field.
func (m *PersonalAccessTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *PersonalAccessTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *PersonalAccessTokenMutation) ResetToken() {
	m.token = nil
}

// ClearPublisher clears the "publisher" edge to the Publisher entity.
func (m *PersonalAccessTokenMutation) ClearPublisher() {
	m.clearedpublisher = true
	m.clearedFields[personalaccesstoken.FieldPublisherID] = struct{}{}
}

// PublisherCleared reports if the "publisher" edge to the Publisher entity was cleared.
func (m *PersonalAccessTokenMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublisherID instead. It exists only for internal usage by the builders.
func (m *PersonalAccessTokenMutation) PublisherIDs() (ids []string) {
	if id := m.publisher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *PersonalAccessTokenMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
}

// Where appends a list predicates to the PersonalAccessTokenMutation builder.
func (m *PersonalAccessTokenMutation) Where(ps ...predicate.PersonalAccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalAccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalAccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalAccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalAccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalAccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalAccessToken).
func (m *PersonalAccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalAccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, personalaccesstoken.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, personalaccesstoken.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, personalaccesstoken.FieldName)
	}
	if m.description != nil {
		fields = append(fields, personalaccesstoken.FieldDescription)
	}
	if m.publisher != nil {
		fields = append(fields, personalaccesstoken.FieldPublisherID)
	}
	if m.token != nil {
		fields = append(fields, personalaccesstoken.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalAccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalaccesstoken.FieldCreateTime:
		return m.CreateTime()
	case personalaccesstoken.FieldUpdateTime:
		return m.UpdateTime()
	case personalaccesstoken.FieldName:
		return m.Name()
	case personalaccesstoken.FieldDescription:
		return m.Description()
	case personalaccesstoken.FieldPublisherID:
		return m.PublisherID()
	case personalaccesstoken.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalAccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalaccesstoken.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case personalaccesstoken.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case personalaccesstoken.FieldName:
		return m.OldName(ctx)
	case personalaccesstoken.FieldDescription:
		return m.OldDescription(ctx)
	case personalaccesstoken.FieldPublisherID:
		return m.OldPublisherID(ctx)
	case personalaccesstoken.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalAccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalaccesstoken.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case personalaccesstoken.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case personalaccesstoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case personalaccesstoken.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case personalaccesstoken.FieldPublisherID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherID(v)
		return nil
	case personalaccesstoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalAccessTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalAccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalAccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalAccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalAccessTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalAccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalAccessTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PersonalAccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalAccessTokenMutation) ResetField(name string) error {
	switch name {
	case personalaccesstoken.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case personalaccesstoken.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case personalaccesstoken.FieldName:
		m.ResetName()
		return nil
	case personalaccesstoken.FieldDescription:
		m.ResetDescription()
		return nil
	case personalaccesstoken.FieldPublisherID:
		m.ResetPublisherID()
		return nil
	case personalaccesstoken.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalAccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.publisher != nil {
		edges = append(edges, personalaccesstoken.EdgePublisher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalAccessTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalaccesstoken.EdgePublisher:
		if id := m.publisher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalAccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalAccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalAccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpublisher {
		edges = append(edges, personalaccesstoken.EdgePublisher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalAccessTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case personalaccesstoken.EdgePublisher:
		return m.clearedpublisher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalAccessTokenMutation) ClearEdge(name string) error {
	switch name {
	case personalaccesstoken.EdgePublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalAccessTokenMutation) ResetEdge(name string) error {
	switch name {
	case personalaccesstoken.EdgePublisher:
		m.ResetPublisher()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken edge %s", name)
}

// PublisherMutation represents an operation that mutates the Publisher nodes in the graph.
type PublisherMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	description                   *string
	website                       *string
	support_email                 *string
	source_code_repo              *string
	logo_url                      *string
	status                        *schema.PublisherStatusType
	clearedFields                 map[string]struct{}
	publisher_permissions         map[int]struct{}
	removedpublisher_permissions  map[int]struct{}
	clearedpublisher_permissions  bool
	nodes                         map[string]struct{}
	removednodes                  map[string]struct{}
	clearednodes                  bool
	personal_access_tokens        map[uuid.UUID]struct{}
	removedpersonal_access_tokens map[uuid.UUID]struct{}
	clearedpersonal_access_tokens bool
	done                          bool
	oldValue                      func(context.Context) (*Publisher, error)
	predicates                    []predicate.Publisher
}

var _ ent.Mutation = (*PublisherMutation)(nil)

// publisherOption allows management of the mutation configuration using functional options.
type publisherOption func(*PublisherMutation)

// newPublisherMutation creates new mutation for the Publisher entity.
func newPublisherMutation(c config, op Op, opts ...publisherOption) *PublisherMutation {
	m := &PublisherMutation{
		config:        c,
		op:            op,
		typ:           TypePublisher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublisherID sets the ID field of the mutation.
func withPublisherID(id string) publisherOption {
	return func(m *PublisherMutation) {
		var (
			err   error
			once  sync.Once
			value *Publisher
		)
		m.oldValue = func(ctx context.Context) (*Publisher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publisher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublisher sets the old Publisher of the mutation.
func withPublisher(node *Publisher) publisherOption {
	return func(m *PublisherMutation) {
		m.oldValue = func(context.Context) (*Publisher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublisherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublisherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Publisher entities.
func (m *PublisherMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublisherMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublisherMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publisher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PublisherMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PublisherMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PublisherMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PublisherMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PublisherMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PublisherMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *PublisherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PublisherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PublisherMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PublisherMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PublisherMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PublisherMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[publisher.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PublisherMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[publisher.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PublisherMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, publisher.FieldDescription)
}

// SetWebsite sets the "website" field.
func (m *PublisherMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PublisherMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PublisherMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[publisher.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PublisherMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[publisher.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PublisherMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, publisher.FieldWebsite)
}

// SetSupportEmail sets the "support_email" field.
func (m *PublisherMutation) SetSupportEmail(s string) {
	m.support_email = &s
}

// SupportEmail returns the value of the "support_email" field in the mutation.
func (m *PublisherMutation) SupportEmail() (r string, exists bool) {
	v := m.support_email
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportEmail returns the old "support_email" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldSupportEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportEmail: %w", err)
	}
	return oldValue.SupportEmail, nil
}

// ClearSupportEmail clears the value of the "support_email" field.
func (m *PublisherMutation) ClearSupportEmail() {
	m.support_email = nil
	m.clearedFields[publisher.FieldSupportEmail] = struct{}{}
}

// SupportEmailCleared returns if the "support_email" field was cleared in this mutation.
func (m *PublisherMutation) SupportEmailCleared() bool {
	_, ok := m.clearedFields[publisher.FieldSupportEmail]
	return ok
}

// ResetSupportEmail resets all changes to the "support_email" field.
func (m *PublisherMutation) ResetSupportEmail() {
	m.support_email = nil
	delete(m.clearedFields, publisher.FieldSupportEmail)
}

// SetSourceCodeRepo sets the "source_code_repo" field.
func (m *PublisherMutation) SetSourceCodeRepo(s string) {
	m.source_code_repo = &s
}

// SourceCodeRepo returns the value of the "source_code_repo" field in the mutation.
func (m *PublisherMutation) SourceCodeRepo() (r string, exists bool) {
	v := m.source_code_repo
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCodeRepo returns the old "source_code_repo" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldSourceCodeRepo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCodeRepo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCodeRepo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCodeRepo: %w", err)
	}
	return oldValue.SourceCodeRepo, nil
}

// ClearSourceCodeRepo clears the value of the "source_code_repo" field.
func (m *PublisherMutation) ClearSourceCodeRepo() {
	m.source_code_repo = nil
	m.clearedFields[publisher.FieldSourceCodeRepo] = struct{}{}
}

// SourceCodeRepoCleared returns if the "source_code_repo" field was cleared in this mutation.
func (m *PublisherMutation) SourceCodeRepoCleared() bool {
	_, ok := m.clearedFields[publisher.FieldSourceCodeRepo]
	return ok
}

// ResetSourceCodeRepo resets all changes to the "source_code_repo" field.
func (m *PublisherMutation) ResetSourceCodeRepo() {
	m.source_code_repo = nil
	delete(m.clearedFields, publisher.FieldSourceCodeRepo)
}

// SetLogoURL sets the "logo_url" field.
func (m *PublisherMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *PublisherMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *PublisherMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[publisher.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *PublisherMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[publisher.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *PublisherMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, publisher.FieldLogoURL)
}

// SetStatus sets the "status" field.
func (m *PublisherMutation) SetStatus(sst schema.PublisherStatusType) {
	m.status = &sst
}

// Status returns the value of the "status" field in the mutation.
func (m *PublisherMutation) Status() (r schema.PublisherStatusType, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldStatus(ctx context.Context) (v schema.PublisherStatusType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PublisherMutation) ResetStatus() {
	m.status = nil
}

// AddPublisherPermissionIDs adds the "publisher_permissions" edge to the PublisherPermission entity by ids.
func (m *PublisherMutation) AddPublisherPermissionIDs(ids ...int) {
	if m.publisher_permissions == nil {
		m.publisher_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.publisher_permissions[ids[i]] = struct{}{}
	}
}

// ClearPublisherPermissions clears the "publisher_permissions" edge to the PublisherPermission entity.
func (m *PublisherMutation) ClearPublisherPermissions() {
	m.clearedpublisher_permissions = true
}

// PublisherPermissionsCleared reports if the "publisher_permissions" edge to the PublisherPermission entity was cleared.
func (m *PublisherMutation) PublisherPermissionsCleared() bool {
	return m.clearedpublisher_permissions
}

// RemovePublisherPermissionIDs removes the "publisher_permissions" edge to the PublisherPermission entity by IDs.
func (m *PublisherMutation) RemovePublisherPermissionIDs(ids ...int) {
	if m.removedpublisher_permissions == nil {
		m.removedpublisher_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publisher_permissions, ids[i])
		m.removedpublisher_permissions[ids[i]] = struct{}{}
	}
}

// RemovedPublisherPermissions returns the removed IDs of the "publisher_permissions" edge to the PublisherPermission entity.
func (m *PublisherMutation) RemovedPublisherPermissionsIDs() (ids []int) {
	for id := range m.removedpublisher_permissions {
		ids = append(ids, id)
	}
	return
}

// PublisherPermissionsIDs returns the "publisher_permissions" edge IDs in the mutation.
func (m *PublisherMutation) PublisherPermissionsIDs() (ids []int) {
	for id := range m.publisher_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPublisherPermissions resets all changes to the "publisher_permissions" edge.
func (m *PublisherMutation) ResetPublisherPermissions() {
	m.publisher_permissions = nil
	m.clearedpublisher_permissions = false
	m.removedpublisher_permissions = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *PublisherMutation) AddNodeIDs(ids ...string) {
	if m.nodes == nil {
		m.nodes = make(map[string]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *PublisherMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *PublisherMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *PublisherMutation) RemoveNodeIDs(ids ...string) {
	if m.removednodes == nil {
		m.removednodes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *PublisherMutation) RemovedNodesIDs() (ids []string) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *PublisherMutation) NodesIDs() (ids []string) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *PublisherMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddPersonalAccessTokenIDs adds the "personal_access_tokens" edge to the PersonalAccessToken entity by ids.
func (m *PublisherMutation) AddPersonalAccessTokenIDs(ids ...uuid.UUID) {
	if m.personal_access_tokens == nil {
		m.personal_access_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.personal_access_tokens[ids[i]] = struct{}{}
	}
}

// ClearPersonalAccessTokens clears the "personal_access_tokens" edge to the PersonalAccessToken entity.
func (m *PublisherMutation) ClearPersonalAccessTokens() {
	m.clearedpersonal_access_tokens = true
}

// PersonalAccessTokensCleared reports if the "personal_access_tokens" edge to the PersonalAccessToken entity was cleared.
func (m *PublisherMutation) PersonalAccessTokensCleared() bool {
	return m.clearedpersonal_access_tokens
}

// RemovePersonalAccessTokenIDs removes the "personal_access_tokens" edge to the PersonalAccessToken entity by IDs.
func (m *PublisherMutation) RemovePersonalAccessTokenIDs(ids ...uuid.UUID) {
	if m.removedpersonal_access_tokens == nil {
		m.removedpersonal_access_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.personal_access_tokens, ids[i])
		m.removedpersonal_access_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPersonalAccessTokens returns the removed IDs of the "personal_access_tokens" edge to the PersonalAccessToken entity.
func (m *PublisherMutation) RemovedPersonalAccessTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedpersonal_access_tokens {
		ids = append(ids, id)
	}
	return
}

// PersonalAccessTokensIDs returns the "personal_access_tokens" edge IDs in the mutation.
func (m *PublisherMutation) PersonalAccessTokensIDs() (ids []uuid.UUID) {
	for id := range m.personal_access_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalAccessTokens resets all changes to the "personal_access_tokens" edge.
func (m *PublisherMutation) ResetPersonalAccessTokens() {
	m.personal_access_tokens = nil
	m.clearedpersonal_access_tokens = false
	m.removedpersonal_access_tokens = nil
}

// Where appends a list predicates to the PublisherMutation builder.
func (m *PublisherMutation) Where(ps ...predicate.Publisher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublisherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublisherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publisher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublisherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublisherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publisher).
func (m *PublisherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublisherMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, publisher.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, publisher.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, publisher.FieldName)
	}
	if m.description != nil {
		fields = append(fields, publisher.FieldDescription)
	}
	if m.website != nil {
		fields = append(fields, publisher.FieldWebsite)
	}
	if m.support_email != nil {
		fields = append(fields, publisher.FieldSupportEmail)
	}
	if m.source_code_repo != nil {
		fields = append(fields, publisher.FieldSourceCodeRepo)
	}
	if m.logo_url != nil {
		fields = append(fields, publisher.FieldLogoURL)
	}
	if m.status != nil {
		fields = append(fields, publisher.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublisherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publisher.FieldCreateTime:
		return m.CreateTime()
	case publisher.FieldUpdateTime:
		return m.UpdateTime()
	case publisher.FieldName:
		return m.Name()
	case publisher.FieldDescription:
		return m.Description()
	case publisher.FieldWebsite:
		return m.Website()
	case publisher.FieldSupportEmail:
		return m.SupportEmail()
	case publisher.FieldSourceCodeRepo:
		return m.SourceCodeRepo()
	case publisher.FieldLogoURL:
		return m.LogoURL()
	case publisher.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublisherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publisher.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case publisher.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case publisher.FieldName:
		return m.OldName(ctx)
	case publisher.FieldDescription:
		return m.OldDescription(ctx)
	case publisher.FieldWebsite:
		return m.OldWebsite(ctx)
	case publisher.FieldSupportEmail:
		return m.OldSupportEmail(ctx)
	case publisher.FieldSourceCodeRepo:
		return m.OldSourceCodeRepo(ctx)
	case publisher.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case publisher.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Publisher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publisher.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case publisher.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case publisher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case publisher.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case publisher.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case publisher.FieldSupportEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportEmail(v)
		return nil
	case publisher.FieldSourceCodeRepo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCodeRepo(v)
		return nil
	case publisher.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case publisher.FieldStatus:
		v, ok := value.(schema.PublisherStatusType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublisherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublisherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublisherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publisher.FieldDescription) {
		fields = append(fields, publisher.FieldDescription)
	}
	if m.FieldCleared(publisher.FieldWebsite) {
		fields = append(fields, publisher.FieldWebsite)
	}
	if m.FieldCleared(publisher.FieldSupportEmail) {
		fields = append(fields, publisher.FieldSupportEmail)
	}
	if m.FieldCleared(publisher.FieldSourceCodeRepo) {
		fields = append(fields, publisher.FieldSourceCodeRepo)
	}
	if m.FieldCleared(publisher.FieldLogoURL) {
		fields = append(fields, publisher.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublisherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublisherMutation) ClearField(name string) error {
	switch name {
	case publisher.FieldDescription:
		m.ClearDescription()
		return nil
	case publisher.FieldWebsite:
		m.ClearWebsite()
		return nil
	case publisher.FieldSupportEmail:
		m.ClearSupportEmail()
		return nil
	case publisher.FieldSourceCodeRepo:
		m.ClearSourceCodeRepo()
		return nil
	case publisher.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Publisher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublisherMutation) ResetField(name string) error {
	switch name {
	case publisher.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case publisher.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case publisher.FieldName:
		m.ResetName()
		return nil
	case publisher.FieldDescription:
		m.ResetDescription()
		return nil
	case publisher.FieldWebsite:
		m.ResetWebsite()
		return nil
	case publisher.FieldSupportEmail:
		m.ResetSupportEmail()
		return nil
	case publisher.FieldSourceCodeRepo:
		m.ResetSourceCodeRepo()
		return nil
	case publisher.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case publisher.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublisherMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.publisher_permissions != nil {
		edges = append(edges, publisher.EdgePublisherPermissions)
	}
	if m.nodes != nil {
		edges = append(edges, publisher.EdgeNodes)
	}
	if m.personal_access_tokens != nil {
		edges = append(edges, publisher.EdgePersonalAccessTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublisherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publisher.EdgePublisherPermissions:
		ids := make([]ent.Value, 0, len(m.publisher_permissions))
		for id := range m.publisher_permissions {
			ids = append(ids, id)
		}
		return ids
	case publisher.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case publisher.EdgePersonalAccessTokens:
		ids := make([]ent.Value, 0, len(m.personal_access_tokens))
		for id := range m.personal_access_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublisherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpublisher_permissions != nil {
		edges = append(edges, publisher.EdgePublisherPermissions)
	}
	if m.removednodes != nil {
		edges = append(edges, publisher.EdgeNodes)
	}
	if m.removedpersonal_access_tokens != nil {
		edges = append(edges, publisher.EdgePersonalAccessTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublisherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case publisher.EdgePublisherPermissions:
		ids := make([]ent.Value, 0, len(m.removedpublisher_permissions))
		for id := range m.removedpublisher_permissions {
			ids = append(ids, id)
		}
		return ids
	case publisher.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case publisher.EdgePersonalAccessTokens:
		ids := make([]ent.Value, 0, len(m.removedpersonal_access_tokens))
		for id := range m.removedpersonal_access_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublisherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpublisher_permissions {
		edges = append(edges, publisher.EdgePublisherPermissions)
	}
	if m.clearednodes {
		edges = append(edges, publisher.EdgeNodes)
	}
	if m.clearedpersonal_access_tokens {
		edges = append(edges, publisher.EdgePersonalAccessTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublisherMutation) EdgeCleared(name string) bool {
	switch name {
	case publisher.EdgePublisherPermissions:
		return m.clearedpublisher_permissions
	case publisher.EdgeNodes:
		return m.clearednodes
	case publisher.EdgePersonalAccessTokens:
		return m.clearedpersonal_access_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublisherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublisherMutation) ResetEdge(name string) error {
	switch name {
	case publisher.EdgePublisherPermissions:
		m.ResetPublisherPermissions()
		return nil
	case publisher.EdgeNodes:
		m.ResetNodes()
		return nil
	case publisher.EdgePersonalAccessTokens:
		m.ResetPersonalAccessTokens()
		return nil
	}
	return fmt.Errorf("unknown Publisher edge %s", name)
}

// PublisherPermissionMutation represents an operation that mutates the PublisherPermission nodes in the graph.
type PublisherPermissionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	permission       *schema.PublisherPermissionType
	clearedFields    map[string]struct{}
	user             *string
	cleareduser      bool
	publisher        *string
	clearedpublisher bool
	done             bool
	oldValue         func(context.Context) (*PublisherPermission, error)
	predicates       []predicate.PublisherPermission
}

var _ ent.Mutation = (*PublisherPermissionMutation)(nil)

// publisherpermissionOption allows management of the mutation configuration using functional options.
type publisherpermissionOption func(*PublisherPermissionMutation)

// newPublisherPermissionMutation creates new mutation for the PublisherPermission entity.
func newPublisherPermissionMutation(c config, op Op, opts ...publisherpermissionOption) *PublisherPermissionMutation {
	m := &PublisherPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePublisherPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublisherPermissionID sets the ID field of the mutation.
func withPublisherPermissionID(id int) publisherpermissionOption {
	return func(m *PublisherPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *PublisherPermission
		)
		m.oldValue = func(ctx context.Context) (*PublisherPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublisherPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublisherPermission sets the old PublisherPermission of the mutation.
func withPublisherPermission(node *PublisherPermission) publisherpermissionOption {
	return func(m *PublisherPermissionMutation) {
		m.oldValue = func(context.Context) (*PublisherPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublisherPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublisherPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublisherPermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublisherPermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublisherPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPermission sets the "permission" field.
func (m *PublisherPermissionMutation) SetPermission(spt schema.PublisherPermissionType) {
	m.permission = &spt
}

// Permission returns the value of the "permission" field in the mutation.
func (m *PublisherPermissionMutation) Permission() (r schema.PublisherPermissionType, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the PublisherPermission entity.
// If the PublisherPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherPermissionMutation) OldPermission(ctx context.Context) (v schema.PublisherPermissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ResetPermission resets all changes to the "permission" field.
func (m *PublisherPermissionMutation) ResetPermission() {
	m.permission = nil
}

// SetUserID sets the "user_id" field.
func (m *PublisherPermissionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PublisherPermissionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PublisherPermission entity.
// If the PublisherPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherPermissionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PublisherPermissionMutation) ResetUserID() {
	m.user = nil
}

// SetPublisherID sets the "publisher_id" field.
func (m *PublisherPermissionMutation) SetPublisherID(s string) {
	m.publisher = &s
}

// PublisherID returns the value of the "publisher_id" field in the mutation.
func (m *PublisherPermissionMutation) PublisherID() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherID returns the old "publisher_id" field's value of the PublisherPermission entity.
// If the PublisherPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherPermissionMutation) OldPublisherID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherID: %w", err)
	}
	return oldValue.PublisherID, nil
}

// ResetPublisherID resets all changes to the "publisher_id" field.
func (m *PublisherPermissionMutation) ResetPublisherID() {
	m.publisher = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PublisherPermissionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[publisherpermission.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PublisherPermissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PublisherPermissionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PublisherPermissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPublisher clears the "publisher" edge to the Publisher entity.
func (m *PublisherPermissionMutation) ClearPublisher() {
	m.clearedpublisher = true
	m.clearedFields[publisherpermission.FieldPublisherID] = struct{}{}
}

// PublisherCleared reports if the "publisher" edge to the Publisher entity was cleared.
func (m *PublisherPermissionMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublisherID instead. It exists only for internal usage by the builders.
func (m *PublisherPermissionMutation) PublisherIDs() (ids []string) {
	if id := m.publisher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *PublisherPermissionMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
}

// Where appends a list predicates to the PublisherPermissionMutation builder.
func (m *PublisherPermissionMutation) Where(ps ...predicate.PublisherPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublisherPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublisherPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublisherPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublisherPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublisherPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublisherPermission).
func (m *PublisherPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublisherPermissionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.permission != nil {
		fields = append(fields, publisherpermission.FieldPermission)
	}
	if m.user != nil {
		fields = append(fields, publisherpermission.FieldUserID)
	}
	if m.publisher != nil {
		fields = append(fields, publisherpermission.FieldPublisherID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublisherPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publisherpermission.FieldPermission:
		return m.Permission()
	case publisherpermission.FieldUserID:
		return m.UserID()
	case publisherpermission.FieldPublisherID:
		return m.PublisherID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublisherPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publisherpermission.FieldPermission:
		return m.OldPermission(ctx)
	case publisherpermission.FieldUserID:
		return m.OldUserID(ctx)
	case publisherpermission.FieldPublisherID:
		return m.OldPublisherID(ctx)
	}
	return nil, fmt.Errorf("unknown PublisherPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publisherpermission.FieldPermission:
		v, ok := value.(schema.PublisherPermissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case publisherpermission.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case publisherpermission.FieldPublisherID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherID(v)
		return nil
	}
	return fmt.Errorf("unknown PublisherPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublisherPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublisherPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PublisherPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublisherPermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublisherPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublisherPermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PublisherPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublisherPermissionMutation) ResetField(name string) error {
	switch name {
	case publisherpermission.FieldPermission:
		m.ResetPermission()
		return nil
	case publisherpermission.FieldUserID:
		m.ResetUserID()
		return nil
	case publisherpermission.FieldPublisherID:
		m.ResetPublisherID()
		return nil
	}
	return fmt.Errorf("unknown PublisherPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublisherPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, publisherpermission.EdgeUser)
	}
	if m.publisher != nil {
		edges = append(edges, publisherpermission.EdgePublisher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublisherPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publisherpermission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case publisherpermission.EdgePublisher:
		if id := m.publisher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublisherPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublisherPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublisherPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, publisherpermission.EdgeUser)
	}
	if m.clearedpublisher {
		edges = append(edges, publisherpermission.EdgePublisher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublisherPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case publisherpermission.EdgeUser:
		return m.cleareduser
	case publisherpermission.EdgePublisher:
		return m.clearedpublisher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublisherPermissionMutation) ClearEdge(name string) error {
	switch name {
	case publisherpermission.EdgeUser:
		m.ClearUser()
		return nil
	case publisherpermission.EdgePublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown PublisherPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublisherPermissionMutation) ResetEdge(name string) error {
	switch name {
	case publisherpermission.EdgeUser:
		m.ResetUser()
		return nil
	case publisherpermission.EdgePublisher:
		m.ResetPublisher()
		return nil
	}
	return fmt.Errorf("unknown PublisherPermission edge %s", name)
}

// StorageFileMutation represents an operation that mutates the StorageFile nodes in the graph.
type StorageFileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	bucket_name   *string
	object_name   *string
	file_path     *string
	file_type     *string
	file_url      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StorageFile, error)
	predicates    []predicate.StorageFile
}

var _ ent.Mutation = (*StorageFileMutation)(nil)

// storagefileOption allows management of the mutation configuration using functional options.
type storagefileOption func(*StorageFileMutation)

// newStorageFileMutation creates new mutation for the StorageFile entity.
func newStorageFileMutation(c config, op Op, opts ...storagefileOption) *StorageFileMutation {
	m := &StorageFileMutation{
		config:        c,
		op:            op,
		typ:           TypeStorageFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageFileID sets the ID field of the mutation.
func withStorageFileID(id uuid.UUID) storagefileOption {
	return func(m *StorageFileMutation) {
		var (
			err   error
			once  sync.Once
			value *StorageFile
		)
		m.oldValue = func(ctx context.Context) (*StorageFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StorageFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorageFile sets the old StorageFile of the mutation.
func withStorageFile(node *StorageFile) storagefileOption {
	return func(m *StorageFileMutation) {
		m.oldValue = func(context.Context) (*StorageFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StorageFile entities.
func (m *StorageFileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageFileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageFileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StorageFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StorageFileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StorageFileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StorageFileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StorageFileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StorageFileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StorageFileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBucketName sets the "bucket_name" field.
func (m *StorageFileMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *StorageFileMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *StorageFileMutation) ResetBucketName() {
	m.bucket_name = nil
}

// SetObjectName sets the "object_name" field.
func (m *StorageFileMutation) SetObjectName(s string) {
	m.object_name = &s
}

// ObjectName returns the value of the "object_name" field in the mutation.
func (m *StorageFileMutation) ObjectName() (r string, exists bool) {
	v := m.object_name
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectName returns the old "object_name" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldObjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectName: %w", err)
	}
	return oldValue.ObjectName, nil
}

// ClearObjectName clears the value of the "object_name" field.
func (m *StorageFileMutation) ClearObjectName() {
	m.object_name = nil
	m.clearedFields[storagefile.FieldObjectName] = struct{}{}
}

// ObjectNameCleared returns if the "object_name" field was cleared in this mutation.
func (m *StorageFileMutation) ObjectNameCleared() bool {
	_, ok := m.clearedFields[storagefile.FieldObjectName]
	return ok
}

// ResetObjectName resets all changes to the "object_name" field.
func (m *StorageFileMutation) ResetObjectName() {
	m.object_name = nil
	delete(m.clearedFields, storagefile.FieldObjectName)
}

// SetFilePath sets the "file_path" field.
func (m *StorageFileMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *StorageFileMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *StorageFileMutation) ResetFilePath() {
	m.file_path = nil
}

// SetFileType sets the "file_type" field.
func (m *StorageFileMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *StorageFileMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "file_type" field.
func (m *StorageFileMutation) ResetFileType() {
	m.file_type = nil
}

// SetFileURL sets the "file_url" field.
func (m *StorageFileMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *StorageFileMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the StorageFile entity.
// If the StorageFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageFileMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *StorageFileMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[storagefile.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *StorageFileMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[storagefile.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *StorageFileMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, storagefile.FieldFileURL)
}

// Where appends a list predicates to the StorageFileMutation builder.
func (m *StorageFileMutation) Where(ps ...predicate.StorageFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StorageFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StorageFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StorageFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StorageFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StorageFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StorageFile).
func (m *StorageFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageFileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, storagefile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, storagefile.FieldUpdateTime)
	}
	if m.bucket_name != nil {
		fields = append(fields, storagefile.FieldBucketName)
	}
	if m.object_name != nil {
		fields = append(fields, storagefile.FieldObjectName)
	}
	if m.file_path != nil {
		fields = append(fields, storagefile.FieldFilePath)
	}
	if m.file_type != nil {
		fields = append(fields, storagefile.FieldFileType)
	}
	if m.file_url != nil {
		fields = append(fields, storagefile.FieldFileURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagefile.FieldCreateTime:
		return m.CreateTime()
	case storagefile.FieldUpdateTime:
		return m.UpdateTime()
	case storagefile.FieldBucketName:
		return m.BucketName()
	case storagefile.FieldObjectName:
		return m.ObjectName()
	case storagefile.FieldFilePath:
		return m.FilePath()
	case storagefile.FieldFileType:
		return m.FileType()
	case storagefile.FieldFileURL:
		return m.FileURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagefile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case storagefile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case storagefile.FieldBucketName:
		return m.OldBucketName(ctx)
	case storagefile.FieldObjectName:
		return m.OldObjectName(ctx)
	case storagefile.FieldFilePath:
		return m.OldFilePath(ctx)
	case storagefile.FieldFileType:
		return m.OldFileType(ctx)
	case storagefile.FieldFileURL:
		return m.OldFileURL(ctx)
	}
	return nil, fmt.Errorf("unknown StorageFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagefile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case storagefile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case storagefile.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case storagefile.FieldObjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectName(v)
		return nil
	case storagefile.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case storagefile.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case storagefile.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	}
	return fmt.Errorf("unknown StorageFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageFileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageFileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StorageFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storagefile.FieldObjectName) {
		fields = append(fields, storagefile.FieldObjectName)
	}
	if m.FieldCleared(storagefile.FieldFileURL) {
		fields = append(fields, storagefile.FieldFileURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageFileMutation) ClearField(name string) error {
	switch name {
	case storagefile.FieldObjectName:
		m.ClearObjectName()
		return nil
	case storagefile.FieldFileURL:
		m.ClearFileURL()
		return nil
	}
	return fmt.Errorf("unknown StorageFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageFileMutation) ResetField(name string) error {
	switch name {
	case storagefile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case storagefile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case storagefile.FieldBucketName:
		m.ResetBucketName()
		return nil
	case storagefile.FieldObjectName:
		m.ResetObjectName()
		return nil
	case storagefile.FieldFilePath:
		m.ResetFilePath()
		return nil
	case storagefile.FieldFileType:
		m.ResetFileType()
		return nil
	case storagefile.FieldFileURL:
		m.ResetFileURL()
		return nil
	}
	return fmt.Errorf("unknown StorageFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageFileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageFileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageFileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StorageFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageFileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StorageFile edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	create_time                  *time.Time
	update_time                  *time.Time
	email                        *string
	name                         *string
	is_approved                  *bool
	is_admin                     *bool
	status                       *schema.UserStatusType
	clearedFields                map[string]struct{}
	publisher_permissions        map[int]struct{}
	removedpublisher_permissions map[int]struct{}
	clearedpublisher_permissions bool
	reviews                      map[uuid.UUID]struct{}
	removedreviews               map[uuid.UUID]struct{}
	clearedreviews               bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetIsApproved sets the "is_approved" field.
func (m *UserMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *UserMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *UserMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(sst schema.UserStatusType) {
	m.status = &sst
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r schema.UserStatusType, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v schema.UserStatusType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// AddPublisherPermissionIDs adds the "publisher_permissions" edge to the PublisherPermission entity by ids.
func (m *UserMutation) AddPublisherPermissionIDs(ids ...int) {
	if m.publisher_permissions == nil {
		m.publisher_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.publisher_permissions[ids[i]] = struct{}{}
	}
}

// ClearPublisherPermissions clears the "publisher_permissions" edge to the PublisherPermission entity.
func (m *UserMutation) ClearPublisherPermissions() {
	m.clearedpublisher_permissions = true
}

// PublisherPermissionsCleared reports if the "publisher_permissions" edge to the PublisherPermission entity was cleared.
func (m *UserMutation) PublisherPermissionsCleared() bool {
	return m.clearedpublisher_permissions
}

// RemovePublisherPermissionIDs removes the "publisher_permissions" edge to the PublisherPermission entity by IDs.
func (m *UserMutation) RemovePublisherPermissionIDs(ids ...int) {
	if m.removedpublisher_permissions == nil {
		m.removedpublisher_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.publisher_permissions, ids[i])
		m.removedpublisher_permissions[ids[i]] = struct{}{}
	}
}

// RemovedPublisherPermissions returns the removed IDs of the "publisher_permissions" edge to the PublisherPermission entity.
func (m *UserMutation) RemovedPublisherPermissionsIDs() (ids []int) {
	for id := range m.removedpublisher_permissions {
		ids = append(ids, id)
	}
	return
}

// PublisherPermissionsIDs returns the "publisher_permissions" edge IDs in the mutation.
func (m *UserMutation) PublisherPermissionsIDs() (ids []int) {
	for id := range m.publisher_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPublisherPermissions resets all changes to the "publisher_permissions" edge.
func (m *UserMutation) ResetPublisherPermissions() {
	m.publisher_permissions = nil
	m.clearedpublisher_permissions = false
	m.removedpublisher_permissions = nil
}

// AddReviewIDs adds the "reviews" edge to the NodeReview entity by ids.
func (m *UserMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.reviews == nil {
		m.reviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the NodeReview entity.
func (m *UserMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the NodeReview entity was cleared.
func (m *UserMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the NodeReview entity by IDs.
func (m *UserMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the NodeReview entity.
func (m *UserMutation) RemovedReviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *UserMutation) ReviewsIDs() (ids []uuid.UUID) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *UserMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.is_approved != nil {
		fields = append(fields, user.FieldIsApproved)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldIsApproved:
		return m.IsApproved()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(schema.UserStatusType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.publisher_permissions != nil {
		edges = append(edges, user.EdgePublisherPermissions)
	}
	if m.reviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePublisherPermissions:
		ids := make([]ent.Value, 0, len(m.publisher_permissions))
		for id := range m.publisher_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpublisher_permissions != nil {
		edges = append(edges, user.EdgePublisherPermissions)
	}
	if m.removedreviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePublisherPermissions:
		ids := make([]ent.Value, 0, len(m.removedpublisher_permissions))
		for id := range m.removedpublisher_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpublisher_permissions {
		edges = append(edges, user.EdgePublisherPermissions)
	}
	if m.clearedreviews {
		edges = append(edges, user.EdgeReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePublisherPermissions:
		return m.clearedpublisher_permissions
	case user.EdgeReviews:
		return m.clearedreviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePublisherPermissions:
		m.ResetPublisherPermissions()
		return nil
	case user.EdgeReviews:
		m.ResetReviews()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
